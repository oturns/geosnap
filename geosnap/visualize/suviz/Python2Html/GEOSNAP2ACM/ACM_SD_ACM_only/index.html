<!DOCTYPE html> 
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<title>Adaptive Choropleth Mapper</title>

	<script src="data/GEO_CONFIG_SD_ACM_only.js"></script>
	<script src="data/GEO_JSON_SD_ACM_only.js"></script>
	<script src="data/GEO_VARIABLES_SD_ACM_only.js"></script>
	
	<script src="../template/Adaptive_Choropleth_Mapper/lib/plotly v1.48.3/plotly.min.js"></script>
	<script src="../template/Adaptive_Choropleth_Mapper/lib/pyextjs-0.1.2/package/dist/ss.js"></script>
	<script src="../template/Adaptive_Choropleth_Mapper/lib/pyextjs-0.1.2/package/dist/Numpy.js"></script>
	<script src="../template/Adaptive_Choropleth_Mapper/lib/pyextjs-0.1.2/package/dist/PolySolve.js"></script>

	<script src="../template/Adaptive_Choropleth_Mapper/lib/jQuery/jquery-3.3.1.js"></script>
	<script src="../template/Adaptive_Choropleth_Mapper/lib/d3 v5.9.7/d3.min.js"></script>
	<script src="../template/Adaptive_Choropleth_Mapper/lib/d3-hexbin v0.2.2/d3-hexbin.v0.2.min.js"></script>
	<script src="../template/Adaptive_Choropleth_Mapper/lib/pearson-correlation/pearson-correlation.js"></script>

	<script src="../template/Adaptive_Choropleth_Mapper/lib/moment/moment.min.js"></script>
	<script src="../template/Adaptive_Choropleth_Mapper/lib/geostats/geostats.min.js"></script>
	<script src="../template/Adaptive_Choropleth_Mapper/lib/simple-statistics@6.0.0/simple-statistics.min.js"></script>

	<link rel="stylesheet" href="../template/Adaptive_Choropleth_Mapper/lib/leaflet@1.5.1/leaflet.css">
	<link rel="stylesheet" href="../template/Adaptive_Choropleth_Mapper/lib/Leaflet.markercluster-master@1.4.1/dist/MarkerCluster.css">
	<link rel="stylesheet" href="../template/Adaptive_Choropleth_Mapper/lib/Leaflet.markercluster-master@1.4.1/dist/MarkerCluster.Default.css">

	<script src="../template/Adaptive_Choropleth_Mapper/lib/leaflet@1.5.1/leaflet.js"></script>
	<script src="../template/Adaptive_Choropleth_Mapper/lib/Leaflet.markercluster-master@1.4.1/dist/leaflet.markercluster.js"></script>

	<script src="../template/Adaptive_Choropleth_Mapper/lib/leaflet-lasso-master@2.0.4/dist/leaflet-lasso.umd.min.js"></script>
	<script src="../template/Adaptive_Choropleth_Mapper/lib/sweetalert/sweetalert.min.js"></script>
	
	<link rel="stylesheet" href="../template/Adaptive_Choropleth_Mapper/css/Adaptive_Choropleth_Mapper.css" />
	<style>
		#tooltip {
			//color: white;
			opacity: .9;
			//background: #333;
			padding: 5px;
			border: 1px solid lightgrey;
			border-radius: 5px;
			font-size: 12px;
			position: absolute;
			//z-index: 10;
			z-index: 1000;
			visibility: hidden;
			white-space: nowrap;
			pointer-events: none;
		}
		#circle circle {
			fill: none;
			pointer-events: all;
		}
		path.group {
			fill-opacity: .9;
		}
		path.chord {
			fill-opacity: .8;
			stroke: #000;
			stroke-width: .25px;
		}
		#circle:hover path.fade {
			display: none;
		}
		text.shadow {
			//stroke: white;
			//stroke-width: 1px;
			//opacity: 0.8;
			text-shadow: 1px 1px 0px #ffffff;
		}
	</style>	
</head>

<body>
	
	<header>
		<h1>Adaptive Choropleth Mapper</h1>	
	</header>
	
	<br>
	<section>
	<div style="height:40px;background-color:transparent; width:1700px;">
		<span>
			<button type="submit" id="submitForm" style="margin:10px 10px 10px 0px; float:left">Submit form</button>
		</span>
		<button type="submit" id="initFiveMaps" style="margin:10px 10px 10px 0px; float:left" hidden>Initialize all maps</button>
		<div id="global-selection" style="margin:1px 0px 1px 30px; float:left; height:55px; border: 1px solid #99CCFF; border-radius: 5px;" hidden>
			<table>
				<tr>
					<td><div id="global_layer" style="margin:3px 0px 0px 15px;"></div><td>
					<td><div id="global_class" style="margin:3px 0px 0px 15px;"></div><td>
					<td><div id="global_count" style="margin:3px 0px 0px 0px;"></div><td>
					<td>
						<div id="global_img" style="margin:3px 0px 0px 15px;"></div>
						<div id="global_color" style="margin:0px 0px 0px 15px;"></div>
					<td>
					<td>
						<div id="local_img" style="margin:3px 0px 0px 10px;"></div>
						<div id="local_color" style="margin:0px 0px 0px 10px;"></div>
					<td>
					<td><div id="global_join" style="margin:3px 10px 0px 15px;"></div><td>
					<td><button id="global_submit" type="submit" style="margin:5px 20px 0px 10px;">Set Globally</button><td>
				</tr>
			</table>
		</div>	
	</div>
	<div id="global-message" style="margin: 0px 160px; width:1100px; color:blue; font-size: smaller; clear:both;" hidden><i>The selections above are valid only after you click "Set Globally" button. To enable "Set Globally", make all maps have the same extents by clicking one of "Sync" buttons below.</i></div>
	</section>
	
	<br><br>
	<section>
	</section>
	<div class='backLayer' style=''></div>
	<div id="mapContainer">
		<div id="map0" class="mapArea"></div><div class="MapBetween"></div>
		<div id="map1" class="mapArea"></div><div class="MapBetween"></div>
		<div id="map2" class="mapArea"></div><div class="MapBetween"></div>
		<div id="map3" class="mapArea"></div><div class="MapBetween"></div>
		<div id="map4" class="mapArea"></div><div class="MapBetween"></div>
		<div id="map5" class="mapArea"></div>
    </div>
	<!--br><br-->
	
	<div id="correlogram"></div>

	<script type="text/javascript">


//global varible
var getNow = function() { return moment().format('HH:mm:ss.SSS '); };
var CA = null;
var app={
	adjustBound: 0.25,							 // ratio to reduce rectangle size of intial bounds
	maxZoom: 14,
	m: 2,                                        // number of maps in a web page shown
	geokey: null,                                // global variable for GEO_JSON and GEO_VARIABLES (ex. tractid)
	geoname: null,                               // global variable for GEO_JSON (ex. County, state or '')
	firstDefinedLayers: [],                      // five layers for user defined layers
	layers: [],                                  // five layers for selected layers
	InitialMapCenter: null,                      // initial map center coordinates from configuration file [34.0522, -118.2437]
	InitialMapZoomLevel: null,                   // initial map zoom level from configuration file (ex. 10)
	StackedChart: true,                          // draw stacked area chart or not form configuration file (default: true)
	Correlogram: true,                           // draw correlogram or not form configuration file (default: true)
	ScatterPlot: true,                           // draw scatter plot or not form configuration file (default: true)
	ParallelCoordinatesPlot: true,               // draw parallel coordinates plot or not form configuration file (default: true)
	NumOfDecimalPlaces: 1,                       // the number of decimal places (default: 1)
	MapWidth: "500px",                           // map width of each map (default: 500px)
	MapHeight: "500px",                          // map height of each map (default: 500px)
	ChartWidth: "500px",                         // width of stacked area chart (default: 500px) 
	ChartHeight: "500px",                        // height of stacked area chart (default: 500px)
	globalLayer: null,                           // global variable for the selected global Layer from the user
	globalClass: null,                           // global variable for the selected global Class from the user
	globalCount: null,                           // global variable for the selected global Count from the user
	globalColor: null,                           // global variable for the selected global Color from the user
	localColor: null,                            // global variable for the selected local Color from the user
	globalJoin: null,                            // global variable for the selected global Join from the user
	titles: [],                                  // global area for the header of result message from server
	values: [],                                  // global area for the values of title index [L001, L002, ....]
	labdic: {},                                  // key: values[n], value: titles[n]
	titdic: {},                                  // key: titles[n], value: values[n]
	inputType: '',                               // input type from web page (ex 'Sync button', :Set Globally button' ... )
	receivedGeoJSON: null,                       // global area for full GeoJSON data from the server
	selectedGeoJSON: null,                       // global area for selected GeoJSON data from full GeoJSON data
	selectedBounds : null,                       // global area for map bounds when selected GeoJSON data update
	fadeCount: 1000,                             // unique fade id for console.log
	faded_at: moment(new Date()),                // fade start time for console.log
	sPointsScatter: [],                          // selected points in the scatter plots
	sPointsParcoords: [],                        // selected points in the parallel coordinates plots
	sPointsMaps: [],                             // selected points in all maps using lasso select
	isLassoPushed: false,                        // states of lasso button in all maps
	maps: {map: null, bounds: null, geojson: null, lasso: null, info: null, legend: null, layers: null, layerscontrol:null, lastHighlightedTractid: null, classification: null, item: null, items: null, zIntervals: null, mIntervals: null, nPolygonbyClass: [0,0,0,0,0,0,0,0,0,0,0]},
	map0: {map: null, bounds: null, geojson: null, lasso: null, info: null, legend: null, layers: null, layerscontrol:null, lastHighlightedTractid: null, classification: null, item: null, items: null, zIntervals: null, mIntervals: null, nPolygonbyClass: []},
	map1: {map: null, bounds: null, geojson: null, lasso: null, info: null, legend: null, layers: null, layerscontrol:null, lastHighlightedTractid: null, classification: null, item: null, items: null, zIntervals: null, mIntervals: null, nPolygonbyClass: []},
	map2: {map: null, bounds: null, geojson: null, lasso: null, info: null, legend: null, layers: null, layerscontrol:null, lastHighlightedTractid: null, classification: null, item: null, items: null, zIntervals: null, mIntervals: null, nPolygonbyClass: []},
	map3: {map: null, bounds: null, geojson: null, lasso: null, info: null, legend: null, layers: null, layerscontrol:null, lastHighlightedTractid: null, classification: null, item: null, items: null, zIntervals: null, mIntervals: null, nPolygonbyClass: []},
	map4: {map: null, bounds: null, geojson: null, lasso: null, info: null, legend: null, layers: null, layerscontrol:null, lastHighlightedTractid: null, classification: null, item: null, items: null, zIntervals: null, mIntervals: null, nPolygonbyClass: []},
	colorGradient1: [[],[]],
	colorGradient19: [[],[]],
};

var RGBwhite = 'rgb(244, 244, 244)';
var RGBpink = 'rgb(255, 192, 203)';
var RGBfuchsia = 'rgb(255, 0, 255)';
var RGBdict = {'rgb(244, 244, 244)': 'RGBwhite', 'rgb(255, 192, 203)': 'RGBpink', 'rgb(255, 0, 255)': 'RGBfuchsia'};

var COLOR_CLASS = {
	//single hue               Black colors must be contained "#252525"
	"Black_5"   : ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
	"Black_6"   : ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"],
	"Black_7"   : ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
	"Black_8"   : ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
	"Black_9"   : ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],	
	"Red_5"     : ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15"],
	"Red_6"     : ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#de2d26", "#a50f15"],
	"Red_7"     : ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
	"Red_8"     : ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
	"Red_9"     : ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
	"Green_5"   : ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"],
	"Green_6"   : ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#31a354", "#006d2c"],
	"Green_7"   : ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
	"Green_8"   : ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
	"Green_9"   : ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],	
	"Blue_5"    : ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"],
	"Blue_6"    : ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#3182bd", "#08519c"],
	"Blue_7"    : ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#2171b5"],
	"Blue_8"    : ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
	"Blue_9"    : ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],	
	"Purple_5"  : ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"],
	"Purple_6"  : ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"],
	"Purple_7"  : ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
	"Purple_8"  : ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
	"Purple_9"  : ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],	
	"Brown_5"   : ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"],
	"Brown_6"   : ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#e6550d", "#a63603"],
	"Brown_7"   : ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
	"Brown_8"   : ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
	"Brown_9"   : ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
	//multi-hue
	"Yellow_to_Red_5"    : ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"],
	"Yellow_to_Red_6"    : ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
	"Yellow_to_Red_7"    : ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
	"Yellow_to_Red_8"    : ["#ffffcc" ,"#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
   	"Yellow_to_Red_9"    : ["#ffffcc" ,"#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
	"Yellow_to_Green_5"  : ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"],
	"Yellow_to_Green_6"  : ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#31a354", "#006837"],
	"Yellow_to_Green_7"  : ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
	"Yellow_to_Green_8"  : ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
	"Yellow_to_Green_9"  : ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
	"Yellow_to_Blue_5"   : ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"],
	"Yellow_to_Blue_6"   : ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"],
	"Yellow_to_Blue_7"   : ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
	"Yellow_to_Blue_8"   : ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
    "Yellow_to_Blue_9"   : ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
	"Pink_to_purple_5"   : ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"],
	"Pink_to_purple_6"   : ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#c51b8a", "#7a0177"],
	"Pink_to_purple_7"   : ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
	"Pink_to_purple_8"   : ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
	"Pink_to_purple_9"   : ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
	"Yellow_to_Brown_5"  : ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"],
	"Yellow_to_Brown_6"  : ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#d95f0e", "#993404"],
	"Yellow_to_Brown_7"  : ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
	"Yellow_to_Brown_8"  : ["#ffffe5" ,"#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
   	"Yellow_to_Brown_9"  : ["#ffffe5" ,"#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
};


	var mbAttr = '' +
			'' +
			'',
		mbUrl = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw';


	var FakeBaseLayers = {
	};	

	
function draw_basemap(mIDX) {
	if (mIDX in app && app[mIDX].map) {
		app[mIDX].map.remove();
	}
	app[mIDX] = $.extend(true, {}, app["maps"]);        // deep copy  ->  all clear mapN global variable
	
	var selected_mapdiv = document.getElementById(mIDX).getElementsByClassName("map")[0];

	var	grayscale   = L.tileLayer(mbUrl, {id: 'mapbox.light'});
	var	streets  = L.tileLayer(mbUrl, {id: 'mapbox.streets'});	
	
	var mapCenter = [37.09024, -95.712891];
	var mapZoomLevel = 4;
	if (app.InitialMapCenter != null) mapCenter = app.InitialMapCenter;
	if (app.InitialMapZoomLevel != null) mapZoomLevel = app.InitialMapZoomLevel;
	app[mIDX].map = L.map(selected_mapdiv, {
		center: mapCenter,
		zoom: mapZoomLevel,
		//maxZoom: app.maxZoom,
		layers: [grayscale] /******************************************************************************************/
	});
	
	app[mIDX].map.scrollWheelZoom.disable();

	var baseLayers = {
		"Grayscale": grayscale,
		"Streets": streets
	};	
}	

function set_decoration_to_auto(mapN) {
	// change labels to line-through using polygons count
	var nPolygon = $("#"+mapN+"_nPolygon").text();
	if (nPolygon) nPolygon = nPolygon.split(' ')[0];
	if (!$.isNumeric(nPolygon)) nPolygon = 0;
	if (nPolygon > 1000 && $("label[for="+mapN+"_auto]").text() == 'Create a group') {
		$("label[for='"+mapN+"_auto']").css('text-decoration', 'line-through');
	} else {
		$("label[for='"+mapN+"_auto']").css('text-decoration', 'none');
	}
}

function draw_titlemap(mIDX, layer) {
	//var html_layer = ' Map'+(mIDX.replace('map','')*1+1)+' &nbsp; &nbsp;Layer: <select name="ACSdata" class="ACSdataSelect" onChange="layer_change(\'' + mIDX + '\')">';
	
	if (!isNaN(mIDX.replace('map','')))								 // Is number?
		$("#"+mIDX+" .map_id").html('&nbsp;<b>Map'+(mIDX.replace('map','')*1+1)+'</b>');
	
	var html_layer = 'Layer: <select name="ACSdata" class="ACSdataSelect" onChange="layer_change(\'' + mIDX + '\')">';
	$.each(app.titles, function(gIdx, title) {
		if (gIdx < 1 && layer != title) return true;
		if (title != layer) {
			html_layer += '<option value="' + app.values[gIdx] + '" class="line_none">' + title + '</option>';
		} else {
			html_layer += '<option value="' + app.values[gIdx] + '" class="line_none" selected>' + title + '</option>';
		}
	});
	if (html_layer.length < 100) 
	html_layer += '<option value="None">No Data</option>';
	html_layer += '</select>'
	$("#"+mIDX+" .map_layer").html(html_layer);
	$(".ACSdataSelect").css({"max-width": app.MapWidth.replace('px','')*1-120+'px'});
	
	// set check box of 'map_metroInterval'  ->  changed metroInterval type from checkbox to radio button
	var fontSize = "font-size: 100%;";
	if (app.MapWidth.replace('px','') < 500) fontSize = "font-size: 90%;";
	if (app.MapWidth.replace('px','') < 450) fontSize = "font-size: 80%;";
	if (app.MapWidth.replace('px','') < 400) fontSize = "font-size: 70%;";
	var html_metroInterval = 
		'<span style="' + fontSize + ' font-style:normal;">' +
		'	 <input type="radio" name="'+mIDX+'-checkbox" value="Global" checked="checked">Global&nbsp;' +
		'	 <input type="radio" name="'+mIDX+'-checkbox" value="Local">Local' +
		'</span>';
	$("#"+mIDX+" .map_metroInterval").html(html_metroInterval);
	
	// if metro interval check box clicked
	$('input[type=radio][name="'+mIDX+'-checkbox"]').change(function() {
		var metroInterval = this.value;
		//console.log(getNow());
		//console.log(getNow(), mIDX, mIDX+"_metroInterval_changed: "+metroInterval);
		app.inputType = mIDX+"_metroInterval_changed: "+metroInterval;         // ex) map0_metroInterval_changed: Global
		globalHeadingRestore();
		
		var nowBounds = app[mIDX].map.getBounds();
		if (!boundsEqual(app.selectedBounds, nowBounds)) {
			//console.log(getNow(), mIDX, 'mapN.map.getBounds() != app.selectedBounds', nowBounds, app.selectedBounds);
			app.selectedBounds = nowBounds;
			updateSelectedGeoJSON(mIDX);
			CA = app.selectedGeoJSON;
		}
		ACSdata_render(mIDX);
	});

	// set sync radio & button
	var leaveGroup = "Leave group";
	if (app.MapWidth.replace('px','') < 400) leaveGroup = "Leave";
	//console.log("app.MapWidth:", app.MapWidth, "    leaveGroup:", leaveGroup, "    fontSize:", fontSize)
	var html_syncbtn = '';
	//html_syncbtn += '<span id="'+mIDX+'_nPolygon" style="' + fontSize + ' display: none;"></span>';
	html_syncbtn += '<span id="'+mIDX+'_nPolygon" style="' + fontSize + '"></span>';
	html_syncbtn += '<span style="' + fontSize + '">&nbsp;&nbsp;</span>';
	html_syncbtn += '<span style="' + fontSize + '">';
	//html_syncbtn += '  <input id="'+mIDX+'_auto" type="radio" value="auto" name="'+mIDX+'-radio">';
	html_syncbtn += '  <input id="'+mIDX+'_auto" type="radio" value="auto" name="'+mIDX+'-radio">';
	html_syncbtn += '  <label for="'+mIDX+'_auto">Create a group</label>';
	html_syncbtn += '</span>';
	html_syncbtn += '<span style="' + fontSize + '">&nbsp;&nbsp;</span>';
	html_syncbtn += '<span style="' + fontSize + '" hidden>';
	html_syncbtn += '  <input id="'+mIDX+'_manual" type="radio" value="manual" name="'+mIDX+'-radio" checked="checked">';
	//html_syncbtn += '  <input id="'+mIDX+'_manual" type="radio" value="manual" name="'+mIDX+'-radio">';
	html_syncbtn += '  <label for="'+mIDX+'_manual">' + leaveGroup + '</label>';
	html_syncbtn += '</span>';
	html_syncbtn += '<span style="' + fontSize + '">&nbsp;&nbsp;&nbsp;&nbsp;</span>';
	html_syncbtn += '<button id="'+mIDX+'_syncbtn" type="button">Sync</button>'
	$("#"+mIDX+" .map_sync").html(html_syncbtn);

	if (app.MapWidth.replace('px','') < 600) $("#"+mIDX+"_nPolygon").hide();
	
	$('input[type=radio][name="'+mIDX+'-radio"]').on('change', function() {
		var sync = $(this).val();
		console.log(getNow());
		console.log(getNow(), mIDX, mIDX+"_sync_"+sync+" clicked");
		app.inputType = mIDX+"_sync_"+sync+" clicked";               // ex) map0_sync_auto clicked  or  map0_sync_manual clicked
		globalHeadingRestore();
		
		var msec = CA.features.length;
		if (msec < 500) msec = 500;
		// drawMode ->  1: draw normal,  2: draw when auto, manual selected,  3: draw all maps force
		if (sync == 'manual') {
			$("#"+mIDX+"_manual").parent().hide();
			$("label[for="+mIDX+"_auto]").html('Join group');        // Create a group -> Joined or Join group
			$("#"+mIDX+" .map").removeClass('borderMaps');
		}
		if (sync == 'auto') {
			$("#"+mIDX+"_manual").parent().show();
			$("label[for="+mIDX+"_auto]").text('Joined');            // Create a group or Join group -> Joined
			$("#"+mIDX+" .map").addClass('borderMaps');
		}
		// get autoLabels in the five maps, hasJoined, baseBounts
		var autoLabels = [];
		var hasJoined = false;
		var baseBounds = null;                                       // the map bounds of already joined map
		for (i=0; i<app.m; i++) {
			var mapN = "map" + i;
			var label = $("label[for="+mapN+"_auto]").text();
			autoLabels.push(label);
			if (label == 'Joined') {
				hasJoined = true;
				if (mIDX != mapN) {
					baseBounds = app[mapN].map.getBounds();
				}
			}
		}

		// maintain the labels:  create a group  ->  Join the map
		for (i=0; i<app.m; i++) {
			var mapN = "map" + i;
			//var nPolygon = $("#"+mapN+"_nPolygon").text();
			if (hasJoined) {
				if ($("label[for="+mapN+"_auto]").text() != 'Joined') {
					$("label[for="+mapN+"_auto]").text('Join group');
				}
				$("label[for='"+mapN+"_auto']").css('text-decoration', 'none');
			} else {
				set_decoration_to_auto(mapN);
			}
		}
	
		// set the check box of global join
		if (getGlobalJoinfromMaps()) {
			$('input[type=checkbox][id="globalJoin"]').prop("checked", true);
			$('label[for="globalJoin"]').css('color', 'red');
		} else {
			$('input[type=checkbox][id="globalJoin"]').prop("checked", false);
			$('label[for="globalJoin"]').css('color', 'gray');
		}
		app.globalJoin = $('input[type=checkbox][id="globalJoin"]').is(":checked");

		if (sync == 'manual') {
			fadeToWindow(mIDX);
			mapOn_movestart_off();
			mapOn_moveend_off();
			setTimeout(function() { 
				redraw_maps(mIDX, 2);
			}, 300); 	
		}
		if (sync == 'auto') {
			fadeToWindow(mIDX);
			mapOn_movestart_off();
			mapOn_moveend_off();
			setTimeout(function() { 
				redraw_maps(mIDX, 2, baseBounds);
			}, 300);
		}
	});
	//$('input[type=radio][name="'+mIDX+'-radio"]:input[value="auto"]').attr("checked", true);    // not working
	
	$("#"+mIDX+"_syncbtn").on('click', function() {
		//console.log(getNow());
		//console.log(getNow(), mIDX, mIDX+"_syncbtn clicked");
		app.inputType = mIDX+"_syncbtn clicked";                     // ex) map1_syncbtn clicked
		globalHeadingRestore();
		
		// get input value of global options
		var globalLayer = $("#global_layer select[name=globalLayer]").val();
		
		// set input value of global options to the header of five maps
		var prvLayers = getLayersfromMaps();
		for (i=0; i<app.m; i++) {
			var mapN = "map" + i;
			if (globalLayer != "none") {
				var layers = globalLayer;
				if (globalLayer == "each") layers = app.titdic[app.firstDefinedLayers[i]];
				$("#"+mapN+" select[name=ACSdata]").val(layers);
			}
		}
		var nowLayers = getLayersfromMaps();
		var isChangedMaps = [];
		for (i=0; i<app.m; i++) {
			var mapN = "map" + i;
			isChangedMaps[i] = false;
			if (nowLayers[i] != prvLayers[i]) isChangedMaps[i] = mapN;
		}
		
		// Joined or Join group -> Create a group
		var globalJoin = $('input[type=checkbox][id="globalJoin"]').is(":checked");
		for (i=0; i<app.m; i++) {
			var mapN = "map" + i;
			if (globalJoin == false) {           // manual
				$("#"+mapN+"_manual").prop("checked", true)
				$("#"+mapN+"_manual").parent().hide();
				$("label[for="+mapN+"_auto]").html('Create a group');
				set_decoration_to_auto(mapN);
				$("#"+mapN+" .map").removeClass('borderMaps');
			}
			if (globalJoin == true) {            // auto
				$("#"+mapN+"_auto").prop("checked", true)
				$("#"+mapN+"_manual").parent().show();
				$("label[for="+mapN+"_auto]").html('Joined');
				set_decoration_to_auto(mapN);
				$("#"+mapN+" .map").addClass('borderMaps');
			}
		}

		fadeToWindow(mIDX);
		mapOn_movestart_off();
		mapOn_moveend_off();
		setTimeout(function() { 
			redraw_maps(mIDX, 3); 
		}, 300);
	});
}


function draw_titleScatterchart(mapN=null) {
	draw_titlemap("Scatterchart", app.layers[2]);
}


function draw_titlePCPchart(mapN=null) {
	//$("#PCPchart .map_id").html('&nbsp;<b>Map'+(app.m+1)+'</b>');
	$("#PCPchart .map_id").html('&nbsp;<b>Parallel Coordinates Plot</b>');
	var html_check = '	 <input id="parcoords-fixAxes" type="checkbox" name="parcoords_fixAxes" value="Fix Axes">' +
					 '   <label for="fixAxes">Fix Axes</label>';
	$("#PCPchart .map_fixAxes").html(html_check);
	var selectedItem = mapN;
	if (mapN) {
		selectedItem = $("#"+mapN+" select[name=ACSdata]").val();
		//var layer = $("#"+mapN+" select[name=ACSdata]").find("option:selected").text();
	}
	console.log("selectedItem:", selectedItem)
	var html_layer = 'Layer: <select name="ACSdata" class="ACSdataSelect" onChange="layer_change(\'' + 'PCPchart' + '\')">';
	//html_layer += '<option value="' + app.values[0] + '" class="line_none">' + app.titles[0] + '</option>';
	//for (var i=0; i<app.m; i++) {
	//	var mapN = "map" + i;
	//	var item  = $("#"+mapN+" select[name=ACSdata]").val();
	//	var layer = $("#"+mapN+" select[name=ACSdata]").find("option:selected").text();
	//	if (item != selectedItem) {
	//		html_layer += '<option value="' + item + '" class="line_none">' + layer + '</option>';
	//	} else {
	//		html_layer += '<option value="' + item + '" class="line_none" selected>' + layer + '</option>';
	//	}
	//}
	$.each(app.titles, function(gIdx, title) {
		if (gIdx < 1) return true;
		if (app.values[gIdx] != selectedItem) {
			html_layer += '<option value="' + app.values[gIdx] + '" class="line_none">' + title + '</option>';
		} else {
			html_layer += '<option value="' + app.values[gIdx] + '" class="line_none" selected>' + title + '</option>';
		}
	});
	if (html_layer.length < 100) 
	html_layer += '<option value="None">No Data</option>';
	html_layer += '</select>'
	$("#PCPchart .map_layer").html(html_layer);
	
	$('input[type=checkbox][id="parcoords-fixAxes"]').change(function() {
		//var fixAxes = $(this).is(":checked");
		var fixAxes = $('input[type=checkbox][id="parcoords-fixAxes"]').is(":checked");
		console.log(getNow(), "parcoords-fixAxes changed:", fixAxes);
		paintParcoords();
	});
}


// get years from #mapN .map_year
//function getYearsfromMaps() {
//	var years = [];
//	for (i=0; i<app.m; i++) {
//		var mapN = "map" + i;
//	    var year = $("#"+mapN+" select[name=yearSelect]").val();
//		years.push(year);
//	}
//	return years;
//}

// get layers from #mapN .map_layer
function getLayersfromMaps() {
	var layers = [];
	for (i=0; i<app.m; i++) {
		var mapN = "map" + i;
	    var layer = $("#"+mapN+" select[name=ACSdata]").val();
		layers.push(layer);
	}
	//console.log(layers)
	return layers;
}

// get joins from #mapN .map_sync
function getJoinsfromMaps() {
	var joins = [];
	for (i=0; i<app.m; i++) {
		var mapN = "map" + i;
		var join = ($('input[type=radio][name="'+mapN+'-radio"]:checked').val() == "auto") ? true : false;
		joins.push(join);
	}
	return joins;
}

// get global year from #mapN .map_year
//function getGlobalYearfromMaps() {
//	var years = Array.from(new Set(getYearsfromMaps()));             // get unique years from #mapN .map_year
//	var year = "none";
//	if (years.length == 5) year = "each";
//	if (years.length == 1) year = years[0];
//	return year;
//}

// get global layer from #mapN .map_layer
function getGlobalLayerfromMaps() {
	var layers = Array.from(new Set(getLayersfromMaps()));           // get unique layers from #mapN .map_year
	var layer = "none";
	if (layers.length == app.m) {                                    // each, if all layers is in the firstDefinedLayers
		//console.log(layers, app.firstDefinedLayers)
		$.each(layers, function(idx, value) {
			if (app.firstDefinedLayers.indexOf(app.titles[value.substring(1)*1]) == -1) return false;
			if (idx == layers.length-1) layer = "each";
			//console.log(idx, layer)
		});
	}
	if (layers.length == 1) layer = layers[0];
	return layer;
}

// get global join from #mapN .map_sync
function getGlobalJoinfromMaps() {
	var joins = Array.from(new Set(getJoinsfromMaps()));             // get unique joins from #mapN .map_sync
	var join = false;
	if (joins.length == 1) join = joins[0];
	return join;
}

// bounds compare with toFixed(2)
function boundsEqual(boundA, boundB) {
	var result = true;
	if ((Math.abs(boundA.getNorth()-boundB.getNorth()) > 0.005) ||             
		(Math.abs(boundA.getEast()-boundB.getEast()) > 0.005) ||               
		(Math.abs(boundA.getSouth()-boundB.getSouth()) > 0.005) ||             
		(Math.abs(boundA.getWest()-boundB.getWest()) > 0.005)) {               
		return false;
	}
	return result;
}

// is bounds of five maps are all same
function isAllBoundsEqual() {
	var bounds = [];
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		bounds.push(app[mapN].map.getBounds());
	}
	var j = 0;
	var isAllSameBounds = true;
	for (var i=1; i<bounds.length; i++) {
		if (!boundsEqual(bounds[i], bounds[0])) {
			isAllSameBounds = false;
			j = i;
			break;
		}
	}
	if (!isAllSameBounds) {
		//console.log('mapX bounds of all maps are not same.  from: [map' + j + ']');
		//console.log(bounds)
	}
	return isAllSameBounds;
}

// is bounds of two maps are all same
function isTwoBoundsEqual(map0, map1) {
	var bounds = [];
	//for (var i=0; i<app.m; i++) {
	//	var mapN = "map" + i;
	//	bounds.push(app[mapN].map.getBounds());
	//}
	bounds.push(app[map0].map.getBounds());
	bounds.push(app[map1].map.getBounds());
	var j = 0;
	var isAllSameBounds = true;
	for (var i=1; i<bounds.length; i++) {
		if (!boundsEqual(bounds[i], bounds[0])) {
			isAllSameBounds = false;
			j = i;
			break;
		}
	}
	if (!isAllSameBounds) {
		//console.log('mapX bounds of all maps are not same.  from: [map' + j + ']');
		//console.log(bounds)
	}
	return isAllSameBounds;
}

// intervals compare
function intervalsEqual(intervalsA, intervalsB) {
	if (intervalsA.length != intervalsB.length) return false;
	for (var i=0; i<intervalsA.length; i++) {
		if (intervalsA[i] != intervalsB[i]) return false;
	}
	return true;
}

// is zIntervals of five maps are all same
function isAllzIntervalsEqual() {
	var j = 0;
	var isAllSameIntervals = true;
	for (i=1; i<app.m; i++) {
		var mapN = "map" + i;
		if (!intervalsEqual(app[mapN].zIntervals, app.map0.zIntervals)) {
			isAllSameIntervals = false;
			j = i;
			break;
		}
	}
	if (!isAllSameIntervals) {
		//console.log('mapX zIntervals of all maps are not same.  from: [map' + j + ']');
	}
	return isAllSameIntervals;
}


// hide or show the 'Set Globally' button
function updateGloballyButton() {
	if (isAllBoundsEqual()) {
		$("#global_submit").show();
	} else {
		$("#global_submit").hide();
	}
}


// draw global selection menu
function draw_globalSelection() {
	
	// set drop-down list of 'global_layer' 
	var html_layer = 'Layer: <select name="globalLayer" class="ACSdataSelect" style="color:red;">';
	html_layer += '<option value="none" class="line_none">No Select</option>';
	html_layer += '<option value="each" class="line_none">Default </option>';
	var theLayer = "";
	$.each(app.titles, function(gIdx, title) {
		if (gIdx < 1) return true;
		if (title != theLayer) {
			html_layer += '<option value="' + app.values[gIdx] + '" class="line_none">' + title + '</option>';
		} else {
			html_layer += '<option value="' + app.values[gIdx] + '" class="line_none" selected>' + title + '</option>';
		}
	});
	if (html_layer.length < 100) 
	html_layer += '<option value="None">No Data</option>';
	html_layer += '</select>' 
	$("#global_layer").html(html_layer);
	$("#global_layer select[name=globalLayer]").val(getGlobalLayerfromMaps());
	if ($("#global_layer select[name=globalLayer]").val() == "none") {
		$("#global_layer select[name=globalLayer]").css('color', 'gray');
	} else {
		$("#global_layer select[name=globalLayer]").css('color', 'red');
	}
	app.globalLayer = $("#global_layer select[name=globalLayer]").val();
	
	if (app.m == 1) {
		$("#global_layer").hide();
	}

	// set drop-down list of 'global_class' 
	var html_layer = 'Classification: <select name="globalClass" style="color:red;">' +
					'<option value="equal" class="line_none">Equal</option>' +
					'<option value="quantile" class="line_none" selected>Quantile</option>' +
					'<option value="ckmeans" class="line_none">Natural Breaks</option>' +
					'<option value="arithmetic" class="line_none">Arithmetic Progression</option>' +
					'<option value="geometric" class="line_none">Geometric Progression</option>' +
					'<option value="std" class="line_none">Std Deviation</option>' +
					'</select>';
	$("#global_class").html(html_layer);
	app.globalClass = $("#global_class select[name=globalClass]").val();
	
	// set drop-down list of 'global_count' 
	var html_count = '<select name="globalCount" style="color:red;">' +
					'<option value="5" class="line_none">5</option>' +
					'<option value="6" class="line_none">6</option>' + 
					'<option value="7" class="line_none">7</option>' +
					'<option value="8" class="line_none" selected>8</option>' +
					'<option value="9" class="line_none">9</option>' +
					'</select>';
	$("#global_count").html(html_count);
	app.globalCount = $("#global_count select[name=globalCount]").val();
	
	// set drop-down list of 'global_color'
	var html_color = '' +
		'<label for="globalColor">Global: </label>' +
		'<select name="globalColor" id="globalColor" style="color:red;">' +
		'	<optgroup label="Single-hue" style="color:black;">' +
		'		<option value="Black" class="line_none">Black</option>' +
		'		<option value="Red" class="line_none">Red</option>' +
		'		<option value="Green" class="line_none">Green</option>' +
		'		<option value="Blue" class="line_none">Blue</option>' +
		'		<option value="Purple" class="line_none">Purple</option>' +
		'		<option value="Brown" class="line_none">Brown</option>' +
		'	</optgroup>' +
		'	<optgroup label="Multi-hue" style="color:black;">' +
		'		<option value="Yellow_to_Red" class="line_none">Yellow_to_Red</option>' +
		'		<option value="Yellow_to_Green" class="line_none">Yellow_to_Green</option>' +
		'		<option value="Yellow_to_Blue" class="line_none">Yellow_to_Blue</option>' +
		'		<option value="Yellow_to_Brown" class="line_none">Yellow_to_Brown</option>' +
		'	</optgroup>' +
		'</select>';
	$("#global_color").html(html_color);
	$("#globalColor").on("change", function(){
		var label = $(this.options[this.selectedIndex]).closest('optgroup').prop('label');
		var value = $(this).val();
		//console.log(label + "/" + value);
		html = '<img src="../template/Adaptive_Choropleth_Mapper/images/' + label + "/" + value + '_s.png" height="10px" width="195px">';
		$("#global_img").html(html);
	});
	$("#globalColor").val("Yellow_to_Red").trigger('change');
	app.globalColor = $("#globalColor").val();
	
	// set drop-down list of 'local_color' 
	var html_color = '' +
		'<label for="localColor">Local: </label>' +
		'<select name="localColor" id="localColor" style="color:red;">' +
		'	<optgroup label="Single-hue" style="color:black;">' +
		'		<option value="Black" class="line_none">Black</option>' +
		'		<option value="Red" class="line_none">Red</option>' +
		'		<option value="Green" class="line_none">Green</option>' +
		'		<option value="Blue" class="line_none">Blue</option>' +
		'		<option value="Purple" class="line_none">Purple</option>' +
		'		<option value="Brown" class="line_none">Brown</option>' +
		'	</optgroup>' +
		'	<optgroup label="Multi-hue" style="color:black;">' +
		'		<option value="Yellow_to_Red" class="line_none">Yellow_to_Red</option>' +
		'		<option value="Yellow_to_Green" class="line_none">Yellow_to_Green</option>' +
		'		<option value="Yellow_to_Blue" class="line_none">Yellow_to_Blue</option>' +
		'		<option value="Yellow_to_Brown" class="line_none">Yellow_to_Brown</option>' +
		'	</optgroup>' +
		'</select>';
	$("#local_color").html(html_color);
	$("#localColor").on("change", function(){
		var label = $(this.options[this.selectedIndex]).closest('optgroup').prop('label');
		var value = $(this).val();
		//console.log(label + "/" + value);
		html = '<img src="../template/Adaptive_Choropleth_Mapper/images/' + label + "/" + value + '_s.png" height="10px" width="195px">';
		$("#local_img").html(html);
	});
	//$("#localColor").val("Black").trigger('change');
	$("#localColor").val("Yellow_to_Blue").trigger('change');
	app.localColor = $("#localColor").val();

	// set check box of 'global_join' 
	var html_join = '<span style="font-size: 80%;">' +
					'	 <input id="globalJoin" type="checkbox" name="join_checkbox" value="groupingAuto">' +
					'    <label for="globalJoin" style="color:gray;">Grouping All</label>' + 
					'</span>';
	$("#global_join").html(html_join);
	app.globalJoin = $('input[type=checkbox][id="globalJoin"]').is(":checked");

	$("#global-selection").show();
	$("#global-message").show();
	
	$("#global_layer select[name=globalLayer]").change(function(){
		var globalLayer = $(this).val();                             // save layer to global variable, if changed
		if ($("#global_layer select[name=globalLayer]").val() == "none") {
			$("#global_layer select[name=globalLayer]").css('color', 'gray');
		} else {
			$("#global_layer select[name=globalLayer]").css('color', 'red');
		}
	});

	$('input[type=checkbox][id="globalJoin"]').change(function(){
		var globalJoin = $(this).is(":checked");
		if (globalJoin == false) {
			$('label[for="globalJoin"]').css('color', 'gray');
		} else {
			$('label[for="globalJoin"]').css('color', 'red');
		}
	});
	
	$("#global_submit").unbind('click').on('click', function(){
		//console.log(getNow());
		//console.log(getNow(), "    ", "_Set_Globally_button clicked");
		app.inputType = "_Set_Globally_button clicked.";             // ex) _Set_Globally_button clicked
		
		app.globalLayer = $("#global_layer select[name=globalLayer]").val();
		app.globalClass = $("#global_class select[name=globalClass]").val();
		app.globalCount = $("#global_count select[name=globalCount]").val();
		app.globalColor = $("#globalColor").val();
		app.localColor  = $("#localColor").val();
		app.globalJoin  = $('input[type=checkbox][id="globalJoin"]').is(":checked");
		
		// check input value of global options
		var globalLayer = $("#global_layer select[name=globalLayer]").val();
		
		// set input value of global options to the header of five maps
		var prvLayers = getLayersfromMaps();
		for (i=0; i<app.m; i++) {
			var mapN = "map" + i;
			var theLayer = globalLayer;
			if (globalLayer != "none") {
				if (globalLayer == "each") theLayer = app.titdic[app.firstDefinedLayers[i]];
				$("#"+mapN+" select[name=ACSdata]").val(theLayer);
			}
		}

		var nowLayers = getLayersfromMaps();
		var isChangedMaps = [];
		for (i=0; i<app.m; i++) {
			var mapN = "map" + i;
			isChangedMaps[i] = false;
			if (nowLayers[i] != prvLayers[i]) isChangedMaps[i] = mapN;
		}
		
		// Joined or Join group -> Create a group
		var globalJoin = $('input[type=checkbox][id="globalJoin"]').is(":checked");
		for (i=0; i<app.m; i++) {
			var mapN = "map" + i;	
			if (globalJoin == false) {           // manual
				$("#"+mapN+"_manual").prop("checked", true)
				$("#"+mapN+"_manual").parent().hide();
				$("label[for="+mapN+"_auto]").html('Create a group');
				set_decoration_to_auto(mapN);
				$("#"+mapN+" .map").removeClass('borderMaps');
			}
			if (globalJoin == true) {            // auto
				$("#"+mapN+"_auto").prop("checked", true)
				$("#"+mapN+"_manual").parent().show();
				$("label[for="+mapN+"_auto]").html('Joined');
				set_decoration_to_auto(mapN);
				$("#"+mapN+" .map").addClass('borderMaps');
			}
		}
		
		$("#correlogram").html("");
		var msec = CA.features.length;
		if (msec < 500) msec = 500;
		//if (msec > 3000)
		swal({
			title: "Please wait...",
			text: "Maps will be ready in "+(msec/1000).toFixed(1)+" seconds.",
			timer: msec,
			//timer: 10000,
			icon: "info",
			buttons: false,
		}).then((value) => {
			//console.log("Redraw all maps by global_submit ended in "+(msec/1000).toFixed(1)+" seconds.");
			setTimeout(function() {
				triggerStackedAreaChart();
				triggerCorrelogram();
				triggerScatterChart();
				triggerParcoords();
			}, 500);
		});
		
		setTimeout(function() {
			mapOn_movestart_off();
			mapOn_moveend_off(); 
			setTimeout(function() { 
				for (var i=0; i<app.m; i++) {
					var mapN = "map" + i;
					drawAmap(mapN, 3);
				}
				setTimeout(function() {
					mapOn_movestart_set();
					mapOn_moveend_set(); 
				}, 500); 
			}, 100); 
		}, 100); 
	});
}


// global heading will restore when did not click "Set Globally" button after selection
function globalHeadingRestore() {
	var message = '';
	
	var eCount = 0;
	if (app.globalLayer != $("#global_layer select[name=globalLayer]").val()) {
		eCount += 1;
		message += 'Layer, ';
		$("#global_layer select[name=globalLayer]").val(app.globalLayer);
		if ($("#global_layer select[name=globalLayer]").val() == "none") {
			$("#global_layer select[name=globalLayer]").css('color', 'gray');
		} else {
			$("#global_layer select[name=globalLayer]").css('color', 'red');
		}
	}
	if (app.globalClass != $("#global_class select[name=globalClass]").val()) {
		eCount += 1;
		message += 'Classification, ';
		$("#global_class select[name=globalClass]").val(app.globalClass);
	}
	if (app.globalCount != $("#global_count select[name=globalCount]").val()) {
		eCount += 1;
		message += 'Classification, ';
		$("#global_count select[name=globalCount]").val(app.globalCount);
	}
	if (app.globalColor != $("#globalColor").val()) {
		eCount += 1;
		message += 'Global Color, ';
		$("#globalColor").val(app.globalColor).trigger('change');
	}
	if (app.localColor != $("#localColor").val()) {
		eCount += 1;
		message += 'Local Color, ';
		$("#localColor").val(app.localColor).trigger('change');
	}
	if (app.globalJoin != $('input[type=checkbox][id="globalJoin"]').is(":checked")) {
		eCount += 1;
		message += 'Grouping-All, ';
		$('input[type=checkbox][id="globalJoin"]').prop('checked', app.globalJoin);
		if ($('input[type=checkbox][id="globalJoin"]').is(":checked") == false) {
			$('label[for="globalJoin"]').css('color', 'gray');
		} else {
			$('label[for="globalJoin"]').css('color', 'red');
		}
	}
	var be = (eCount > 1) ? 'are' : 'is'
	
	if (eCount > 0) {
		message = 'Your selection in ' + message.substring(0, message.length-2) + ' ';
		message += be + ' not valid because you have not clicked "Set Globally" button.\n\n';
		message += 'To enable "Set Globally" button, ';
		message += 'make all maps have the same extents by clicking one of "Sync" buttons on the top of each map.';
		swal({
			title: "Attention!",
			text: message,
			icon: "warning",
			button: "CONTINUE",
		});
	}
}


function layer_change(mIDX) {
	if (mIDX == "Scatterchart") {
		app.inputType = mIDX+"_layer changed";						 // ex) Scatterchart_layer changed
		globalHeadingRestore();
		triggerScatterChart();
		return;
	}
	if (mIDX == "PCPchart") {
		app.inputType = mIDX+"_layer changed";						 // ex) PCPchart_layer changed
		globalHeadingRestore();
		triggerParcoords();
		return;
	}
	
	//draw_titleScatterchart(mIDX);
	draw_titlePCPchart(mIDX);
	
	// set global_layer
	$("#global_layer select[name=globalLayer]").val(getGlobalLayerfromMaps());
	if ($("#global_layer select[name=globalLayer]").val() == "none") {
		$("#global_layer select[name=globalLayer]").css('color', 'gray');
	} else {
		$("#global_layer select[name=globalLayer]").css('color', 'red');
	}
	app.globalLayer = $("#global_layer select[name=globalLayer]").val()
	headerChange(mIDX);
}

function headerChange(mIDX) {
	//console.log(getNow());
	//console.log(getNow(), mIDX, mIDX+"_header changed");
	app.inputType = mIDX+"_header changed";							 // ex) map0_header changed
	globalHeadingRestore();
	
	fadeToWindow(mIDX);
	mapOn_movestart_off();
	mapOn_moveend_off();
	setTimeout(function() { 
		redraw_maps(mIDX, 2); 
	}, 300);
};


// clear info, legend, layers in the map
function clear_map(mIDX) {
	if (app[mIDX].info) {
		app[mIDX].info.remove();
		app[mIDX].info = null;
	}
	if (app[mIDX].legend) {
		app[mIDX].legend.remove();
		app[mIDX].legend = null;
	}
	if (app[mIDX].layerscontrol) {
		app[mIDX].layerscontrol.remove();
		app[mIDX].layerscontrol = null;
	}
	if (app[mIDX].map.hasLayer(app[mIDX].geojson)) {
		app[mIDX].map.removeLayer(app[mIDX].geojson);
		app[mIDX].geojson = null;
	}
}


// items = [nhwht10] or [nhwht10, nhwht70, .....]
function geostats_classification(classification, nClass, geojson, items) {   

	var values = [];
	var j=0;
	for (var l=0; l<items.length; l++) {
		item = items[l];
		for (var i=0; i<geojson.features.length; i++) {
			if (!(item in geojson.features[i].properties)) continue;
			if (geojson.features[i].properties[item] == -9999) continue;
			values[j++] = geojson.features[i].properties[item];
		}
	}
	if (values.length == 0) {
		return null;
	}
	var maxInterval = nClass * 1;
	if (maxInterval > values.length) {
		maxInterval = values.length;
		if (classification == "quantile") maxInterval = values.length - 1;
	}
	
	values.sort(function(a,b){return a-b});
	var intervals = [];
	
	if (classification != 'ckmeans') {                               // using geostats.js
		var serie = new geostats();
		serie.setSerie(values);
		var ranges = [];                                             // ranges.length = maxInterval + 1
		if (classification == 'equal')      ranges = serie.getClassEqInterval(maxInterval);
		if (classification == 'quantile')   ranges = serie.getClassQuantile(maxInterval);
		if (classification == 'std')        ranges = serie.getClassStdDeviation(maxInterval);
		if (classification == 'arithmetic') ranges = serie.getClassArithmeticProgression(maxInterval);
		if (classification == 'geometric')  ranges = serie.getClassGeometricProgression(maxInterval);
		if (classification != 'quantile') {
			intervals = ranges.slice(0, -1);
		} else {
			intervals = [ranges[0]];
			var r = 1;
			for (var v=0; v<values.length; v++) {
				if (values[v] == ranges[r]) {
					var n = v + 1;
					if (n >= values.length) n = v;
					intervals.push(values[n]);
					if (intervals.length >= maxInterval) break;
					if (++r >= ranges.length) break;
				}
			}	
		}
	}
	
	if (classification == 'ckmeans') {                               // using simple-statistics
		var clusteredValues = ss.ckmeans(values, maxInterval);
		for (var key in clusteredValues) {
			clusteredValue = clusteredValues[key];
			intervals.push(clusteredValue[0]);
		}
	}

	if (intervals.length > nClass) intervals = intervals.slice(0, nClass);

	return intervals;
}


function drawAmap(mIDX, drawMode) { 
	// drawMode ->  1: draw normal,  2: draw when auto, manual selected,  3: draw all maps force
	if (!drawMode) drawMode = 1;

	var map = app[mIDX].map;

	var selectedLayer  = $("#"+mIDX+" select[name=ACSdata]").val();
	var classification = $("#global_class select[name=globalClass]").val();
	var nClass = $("#global_count select[name=globalCount]").val();
	var selectedLayerIndex  = $("#"+mIDX+" select[name=ACSdata]").prop('selectedIndex');
	
	// set color scheme to global area
	//var colorScheme = colorSeries + nClass;
	//if (!(colorScheme in COLOR_CLASS)) colorScheme = 'Orange8';       // default is the Orange8
	//app.colorGradient1 = COLOR_CLASS[colorScheme];
	//app.colorGradient19 = app.colorGradient1.slice().concat(['#5E5E5E']);

	var item = selectedLayer;
	//console.log(getNow(), mIDX, selectedLayer,
	//	' ['+selectedLayerIndex+':', '"'+item+'"] ', classification, ' draw a map started');
	
	// change labels to line-through using polygons count
	var count = CA.features.length;	
	$("#"+mIDX+"_nPolygon").text(count + ' Polygons');               // Polygons
	set_decoration_to_auto(mIDX);

	var items = [];
	var globalJoin = $('input[type=checkbox][id="globalJoin"]').is(":checked");
	var this_sync = $('input[type=radio][name="'+mIDX+'-radio"]:checked').val();
	//console.log('drawMode: ', drawMode, 'globalJoin: ', globalJoin, 'app.inputType: ', app.inputType);
	for (var i=0; i<app.m; i++) {
		var div_id = "map" + i;
		var that_sync = $('input[type=radio][name="'+div_id+'-radio"]:checked').val();
		if (drawMode != 3) {
			if (div_id != mIDX && (this_sync == 'auto' && that_sync == 'manual')) continue;
			if (div_id != mIDX && (this_sync == 'manual')) continue;
		}
		if (drawMode == 3) {
			//if (app.inputType.indexOf("_syncbtn clicked") < 0)       // ex) "map1_syncbtn clicked"
			if (div_id != mIDX && globalJoin == false) continue;
		}
		var sLayer = $("#"+div_id+" select[name=ACSdata]").val();
		items.push(sLayer);
	}
	//console.log(getNow(), mIDX, 'items for interval:', items);
	
	// re-calculate zoomed intervals and save it to app.mapN.zIntervals
	//console.log(getNow(), mIDX, classification+' zIntervals started', nClass, CA, items);
	app[mIDX].zIntervals = geostats_classification(classification, nClass, CA, items);
	//console.log(getNow(), mIDX, classification+' zIntervals:', app[mIDX].zIntervals);
	if (!app[mIDX].zIntervals) {
		$("#"+mIDX+"_nPolygon").text("No Data");
		clear_map(mIDX);
		return;
	}

	// re-calculate metro intervals and save it to app.mapN.mIntervals ==> global
	app[mIDX].classification = classification;
	app[mIDX].item = item;
	app[mIDX].items = items.toString();
	//console.log(getNow(), mIDX, classification+' mIntervals started', item, items.toString());
	app[mIDX].mIntervals = geostats_classification(classification, nClass, app.receivedGeoJSON, items);
	//console.log(getNow(), mIDX, classification+' mIntervals:', app[mIDX].mIntervals);

	ACSdata_render(mIDX);
}


function ACSdata_render(mIDX) {

		var map = app[mIDX].map;
		var item = app[mIDX].item;
		
		//var metroInterval = $('input[type=checkbox][name="'+mIDX+'-checkbox"]').is(":checked");
		var GorL = $('input[type=radio][name="'+mIDX+'-checkbox"]:checked').val();
		//console.log("GorL: ", GorL);
		var zIntervals = app[mIDX].zIntervals;
		var mIntervals = app[mIDX].mIntervals;
		
		var nClass = $("#global_count select[name=globalCount]").val();
		var globalColorSeries = $("#globalColor").val();
		var localColorSeries  = $("#localColor").val();
		var colorScheme;
		var zm;
		if (GorL == "Global") zm = 0;                                          // global interval
		if (GorL == "Local")  zm = 1;                                          // local interval
		
		colorScheme = globalColorSeries + '_' + nClass;
		if (!(colorScheme in COLOR_CLASS)) colorScheme = 'Yellow_to_Red_8';    // default color of global
		//console.log("global colorScheme: "+colorScheme);
		app.colorGradient1[0] = COLOR_CLASS[colorScheme];
		app.colorGradient19[0] = app.colorGradient1[0].slice();
		if (app.colorGradient19[0].indexOf("#252525") == -1) app.colorGradient19[0].push('#5E5E5E');
		else                                                 app.colorGradient19[0].push('#FFB3B3');
		
		colorScheme = localColorSeries + '_' + nClass;
		if (!(colorScheme in COLOR_CLASS)) colorScheme = 'Black_8';		   	   // default color of local
		//console.log("local colorScheme: "+colorScheme);
		app.colorGradient1[1] = COLOR_CLASS[colorScheme];
		app.colorGradient19[1] = app.colorGradient1[1].slice();
		if (app.colorGradient19[1].indexOf("#252525") == -1) app.colorGradient19[1].push('#5E5E5E');
		else                                                 app.colorGradient19[1].push('#FFB3B3');
		
		// control that lasso select
		if (app[mIDX].lasso != null) {
			initializeLassoButtons(mIDX);
			app[mIDX].lasso.remove();
		}
		if (app.ScatterPlot == true || app.ParallelCoordinatesPlot == true) {
			app[mIDX].lasso = L.control.lasso({intersect: true,  position: 'topleft'}).addTo(map);
			//app[mIDX].lasso = L.control.lasso({position: 'topleft'}).addTo(map);
			$("#"+mIDX+" .leaflet-control-lasso").css('background-color', RGBwhite);
		}
		// -- or --
		//if (!$("#"+mIDX+" .leaflet-control-lasso").attr("title")) {				// if lasso button not existed
		//	app[mIDX].lasso = L.control.lasso({intersect: true,  position: 'topleft'}).addTo(map);
		//	$("#"+mIDX+" .leaflet-control-lasso").css('background-color', RGBwhite);
		//}
		
		// control that shows state info on hover
		if (app[mIDX].info != null) app[mIDX].info.remove();
		app[mIDX].info = L.control();
		app[mIDX].info.onAdd = function (map) {
			this._div = L.DomUtil.create('div', 'info infolegend');
			this.update();
			return this._div;
		};
		app[mIDX].info.update = function (props) {
			var v = (props && item in props && props[item] != -9999) ? props[item] : "No Data";
			var c = '';
			var nm = getClass1(v * 1.0, "m");
			var nz = getClass1(v * 1.0, "z");
			var fm = (nm > 4) ? 'white' : 'black';
			var fz = (nz > 4) ? 'white' : 'black';
			var cm = '<i style="color:'+fm+'; background:' + getColor1(v * 1.0, "m") + '">' + nm + '</i>';
			var cz = '<i style="color:'+fz+'; background:' + getColor1(v * 1.0, "z") + '">' + nz + '</i>';
			if (GorL == "Global") c = '<span> )</span>' + cz + '<span> &nbsp; (L: </span>' + cm + '<span> G: </span>';
			if (GorL == "Local")  c = '<span> )</span>' + cm + '<span> &nbsp; (G: </span>' + cz + '<span> L: </span>';
			this._div.innerHTML = '<h4></h4>' +  (props ?
				'<b> ' + ((typeof v === 'number') ? v.toFixed(app.NumOfDecimalPlaces) : v) + '</b> &nbsp; ' + c + '<br/>'
				+ ((app.geoname != "") ? app.geoname+' : '+props[app.geoname]+'<br/>' : '')
				+ app.geokey+' : '+props[app.geokey]
				: 'Hover over an area');
		};
		app[mIDX].info.addTo(map);

		// get getOpacity
		function getOpacity1(feature) {
			return 0.9; /************************************************************************************/
		}
		
		// get color depending on selected layer's value
		function getColor1(d, interval) {
			var intervals = (GorL == "Global") ? mIntervals : zIntervals;
			var m = zm;
			if (interval == 'm') {intervals = mIntervals; m = 0;}
			if (interval == 'z') {intervals = zIntervals; m = 1;}
			if (!$.isNumeric(d) || d == "-9999") {                   // NO DATA
				if (app.colorGradient1[m].indexOf("#252525") == -1) return "#5E5E5E";
				else return "#FFB3B3";
			}
			for (var i=app.colorGradient1[m].length-1; i>=0; i--) {
				if (d >= intervals[i]) {
					return app.colorGradient1[m][i];
				}
			}
		}
		function getClass1(d, interval) {
			if (!$.isNumeric(d) || d == "-9999") return "";
			var intervals = (GorL == "Global") ? mIntervals : zIntervals;
			if (interval == 'm') intervals = mIntervals;
			if (interval == 'z') intervals = zIntervals;
			for (var i=app.colorGradient1[zm].length-1; i>=0; i--) {
				if (d >= intervals[i]) {
					return i+1;
				}
			}
		}
		
		function style1(feature) {
			return {
				weight: 0.3,
				opacity: 1,
				color: 'white',
				dashArray: '1',
				fillOpacity: getOpacity1(feature),
				fillColor: getColor1(feature.properties[item])
			};
		}

		function highlightFeature(e) {
			var layer = e.target;
			//var sIDX = layer._map.getContainer().parentNode.id;
			//console.log("mIDX:", mIDX, "sIDX:", sIDX)                // mIDX == sIDX ???
			var layerid = layer._leaflet_id;
			var tractid = layer.feature.properties[app.geokey];
			//app[mIDX].lastHighlightedTractid = tractid;
			if (app.isLassoPushed == false) {
				layer.setStyle({
					weight: 3,
					color: '#00ffff',
					dashArray: '',
					fillOpacity: 0.9
				});
				for (i=0; i<app.m; i++) {
					var mapN = "map" + i;
					if (mIDX == mapN) continue;
					if (!app[mapN].geojson) continue;
					var layerN = app[mapN].geojson._layers[app[mapN].layers[tractid]];
					if (!layerN) continue;
					layerN.setStyle({
						weight: 3,
						color: '#666',
						dashArray: '',
						fillOpacity: 0.9
					});
				}
				if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
					for (i=0; i<app.m; i++) {
						var mapN = "map" + i;
						if (!app[mapN].geojson) continue;
						var layerN = app[mapN].geojson._layers[app[mapN].layers[tractid]];
						if (!layerN) continue;
						layerN.bringToFront();
					}
				}
			}
			for (i=0; i<app.m; i++) {
				var mapN = "map" + i;
				if (app[mapN].info) app[mapN].info.update(layer.feature.properties);
			}
		}
		
		function resetHighlight(e) {
			var layer = e.target;
			var tractid = layer.feature.properties[app.geokey];
			if (app.isLassoPushed == false) {
				for (i=0; i<app.m; i++) {
					var mapN = "map" + i;
					if (!app[mapN].geojson) continue;
					var layerN = app[mapN].geojson._layers[app[mapN].layers[tractid]];
					if (!layerN) continue;
					app[mapN].geojson.resetStyle(layerN);
				}
			}
			for (i=0; i<app.m; i++) {
				var mapN = "map" + i;
				if (app[mapN].info) app[mapN].info.update();
			}
		}
		
		function zoomToFeature(e) {
			map.fitBounds(e.target.getBounds());
		}

		function onEachFeature(feature, layer) {
			layer.on({
				mouseover: highlightFeature,
				mouseout: resetHighlight,
				//click: zoomToFeature
				//click: highlightFeature
			});
		}
		
		// layer that shows data
		if (map.hasLayer(app[mIDX].geojson)){
			map.removeLayer(app[mIDX].geojson);	
			
		}
		
		app["maps"].gPolygonbyClass = [];
		for (var i=0; i<app.colorGradient1[0].length+2; i++) app["maps"].gPolygonbyClass.push(0);
		//console.log('app["maps"].gPolygonbyClass', app["maps"].gPolygonbyClass.length, app["maps"].gPolygonbyClass);
		app[mIDX].gPolygonbyClass = app["maps"].gPolygonbyClass.slice();                 // clear gPolygonbyClass
		//console.log('app['+mIDX+'].gPolygonbyClass', app[mIDX].gPolygonbyClass.length, app[mIDX].gPolygonbyClass);
		$.each(app.receivedGeoJSON.features, function(idx, feature) {
			var v = (item in feature.properties && feature.properties[item] != -9999) ? feature.properties[item] : "No Data";
			var c = getClass1(v * 1.0, "m");
			if (c == "") c = app.colorGradient1[0].length + 1;        // may be 9
			app[mIDX].gPolygonbyClass[0] += 1;
			app[mIDX].gPolygonbyClass[c] += 1;
		});
		//console.log('app['+mIDX+'].gPolygonbyClass', app[mIDX].gPolygonbyClass.length, app[mIDX].gPolygonbyClass);
		
		app["maps"].nPolygonbyClass = [];
		for (var i=0; i<app.colorGradient1[1].length+2; i++) app["maps"].nPolygonbyClass.push(0);
		//console.log('app["maps"].nPolygonbyClass', app["maps"].nPolygonbyClass.length, app["maps"].nPolygonbyClass);
		app[mIDX].nPolygonbyClass = app["maps"].nPolygonbyClass.slice();                 // clear nPolygonbyClass
		//console.log('app['+mIDX+'].nPolygonbyClass', app[mIDX].nPolygonbyClass.length, app[mIDX].nPolygonbyClass);
		$.each(CA.features, function(idx, feature) {
			var v = (item in feature.properties && feature.properties[item] != -9999) ? feature.properties[item] : "No Data";
			var c = getClass1(v * 1.0, "z");
			if (c == "") c = app.colorGradient1[0].length + 1;        // may be 9
			app[mIDX].nPolygonbyClass[0] += 1;
			app[mIDX].nPolygonbyClass[c] += 1;
		});
		//console.log('app['+mIDX+'].nPolygonbyClass', app[mIDX].nPolygonbyClass.length, app[mIDX].nPolygonbyClass);
		
		app[mIDX].geojson = L.geoJson(CA, {
			style: style1,
			onEachFeature: onEachFeature
		}).addTo(map);
	

		var overlays = {
			"layer": app[mIDX].geojson, /***************************************************************************************/
		};
		

		// Create layercontrol. Before create, remove layercontrol if it exists
		if (app[mIDX].layerscontrol ) {
			app[mIDX].layerscontrol.remove();			
		}	
	    app[mIDX].layerscontrol = L.control.layers(FakeBaseLayers, overlays, {
			position: 'bottomleft',                                  // 'topleft', 'bottomleft', 'bottomright'
			collapsed: false,                                        // true
			//autoZIndex: false
		}).addTo(app[mIDX].map);
		
		app[mIDX].layers = {};
		app[mIDX].geojson.eachLayer(function(layer) {
			var layerid = layer._leaflet_id;
			var tractid = layer.feature.properties[app.geokey];
			app[mIDX].layers[tractid] = layerid;
		})

		// control that shows legend
		if (app[mIDX].legend != null) app[mIDX].legend.remove();
		app[mIDX].legend = L.control({position: 'bottomright'});
		
		app[mIDX].legend.onAdd = function (map) {
			var div = L.DomUtil.create('div', 'info legend');
			var intervals = (GorL == "Global") ? mIntervals : zIntervals;
			var labels = (GorL == "Global") ? 
							['<center><strong>Global</strong><font size="1" face="Arial Narrow"></br>lower bounds</font></center>'] : 
							['<center><strong>Local</strong><font size="1" font-family:"Arial Narrow"></br>lower bounds</font></center>']; 
							//['<center><strong>Global</strong><font size="1"></br></font></center>'] : 
							//['<center><strong>Local</strong><font size="1"></br></font></center>']; 
			var classValue;
			for (var i = 0; i < app.colorGradient1[zm].length; i++) {
				if (i < intervals.length) classValue = intervals[i].toFixed(app.NumOfDecimalPlaces);
				else                      classValue = "&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;";
				labels.push('<i style="background:' + app.colorGradient1[zm][i] + '"></i> ' + classValue);
			}
			labels.push('<i style="background:' + getColor1(-9999) + '"></i> ' + 'No Data'+ '<br> ');    // last legend			
			div.innerHTML = labels.join('<br>');
			return div;
		};
		
		app[mIDX].legend.addTo(map);
}


// starts here !!
$( document ).ready(function() {
	// Set up the AJAX indicator
    $('body').append('<div id="ajaxBusy"><p id="ajaxBusyMsg">Please wait...</p></div>');
	
	//console.log(getNow());
	//console.log(getNow(), "    ", "_function_ready started");
	app.inputType = "_function_ready started";                       // ex) _function_ready started

	
	//console.log(GEO_JSON.features.length, GEO_JSON);
	//console.log(GEO_VARIABLES);
	
	// build app.receivedGeoJSON from GEO_JSON and GEO_VARIABLES
	app.titles = GEO_VARIABLES[0].slice();
	app.geokey = app.titles[0];
	app.titles[0] = 'Select the 3rd variable';
	app.values = [];
	app.labdic = {};
	app.titdic = {};
	for (var i=0; i<app.titles.length; i++) {
		var value = 'L'+zeroPad(i, 3);
		app.values.push(value);
		//if (i != 0) app.labdic[value] = app.titles[i];
		//if (i != 0) app.labdic[value] = {'shortName': app.titles[i].substr(5), 'fullName': app.titles[i]};
		//if (i != 0) app.titdic[app.titles[i]] = value;
		app.labdic[value] = {'shortName': app.titles[i].substr(5), 'fullName': app.titles[i]};
		app.titdic[app.titles[i]] = value;
	}
	//console.log(app.titles, app.values, app.titdic)
	var geokey = app.geokey;
	
	if (!('features' in GEO_JSON) || GEO_JSON.features.length < 1) {
		swal({
			title: "Alert!",
			text: "The 'GEO_JSON' you provided has no 'features'.",
			icon: "error",
			button: "ABORT",
		});
		return;
	}
	
	//var firstProperty = GEO_JSON.features[0].properties;
	var firstProperty = $.extend(true, {}, GEO_JSON.features[0].properties);             // deep copy of the object
	if (!(geokey in firstProperty)) {
		swal({
			title: "Alert!",
			text: "The key in your geojosn should match the key in your attributes.",
			icon: "error",
			button: "ABORT",
		});
		return;
	}
	
	delete firstProperty[geokey];
	//console.log(firstProperty);
	app.geoname = (Object.keys(firstProperty).length > 0) ? Object.keys(firstProperty)[0] : "";
	var geoname = app.geoname;
	//console.log(geoname);
	
	
	var geoFeatures = {}                                             // key: geokey,  value: geometry
	var nError = 0;
	$.each(GEO_JSON.features, function(rIdx, row) {
		//console.log(row);
		var tractid = ('properties' in row && geokey in row.properties) ? row.properties[geokey] : "";
		var geometry = ('geometry' in row) ? row.geometry : {};
		if (tractid == "") {
			//console.log("The key '"+geokey+"' is not found in the GEO_JSON["+rIdx+"]", row);
			nError += 1;
			return true;
		}
		if ($.isEmptyObject(geometry)) {
			//console.log("The 'geometry' is not found in the GEO_JSON["+rIdx+"]", row);
			nError += 1;
			return true;
		}
		geoFeatures[tractid] = {'geometry': geometry, 'properties': row.properties};
	});
	//console.log(nError, Object.keys(geoFeatures).length, geoFeatures);
	
	if (Object.keys(geoFeatures).length == 0) {
		swal({
			title: "Alert!",
			text: "The 'GEO_JSON' you provided is not valid.\nPlease check it.",
			icon: "error",
			button: "ABORT",
		});
		return;
	}
	if (nError != 0) {
		swal({
			title: "Attention!",
			text: "The 'GEO_JSON' you provided has "+nError+" errors.\nProceed anyway?",
			icon: "warning",
			button: "CONTINUE",
		});
	}
	
	nError = 0;
	app.receivedGeoJSON = {"type":"FeatureCollection", "features":[]}
	$.each(GEO_VARIABLES, function(rIdx, row) {
		if (rIdx == 0) return true;                                  // skip title's row
		var geokey = row[0];
		if (!(geokey in geoFeatures)) {
			//console.log("The key '"+geokey+"' is not found in the GEO_JSON.");
			nError += 1;
			return true;
		}
		var geoFeature = geoFeatures[geokey];
		var feature = {"type": "Feature", "geometry": geoFeature["geometry"], "properties": geoFeature["properties"]};
		//feature.properties[app.values[0]] = (rIdx == 1) ? 1 : -9999;
		feature.properties[app.values[0]] = -9999;
		$.each(row, function(cIdx, col) {
			if (cIdx < 1) return true;                               // skip key's row (first column is the geokey)
			feature.properties[app.values[cIdx]] = row[cIdx] * 1.0;
		});
		app.receivedGeoJSON["features"].push(feature);
	});
	
	CA = app.receivedGeoJSON;
	app.selectedGeoJSON = app.receivedGeoJSON;	
	//console.log(CA);
	
	// set number of maps to app.m
	app.m = 5;                                                       // default 5 maps
	if (typeof NumOfMaps !== 'undefined' && typeof NumOfMaps === 'number') {
		if (NumOfMaps >= 1 && NumOfMaps <= 15) app.m = NumOfMaps;
	}
	if (app.titles.length <= app.m) app.m = app.titles.length - 1;
	
	// set draw stacked area chart or not to global variable
	if (typeof Stacked_Chart !== 'undefined' && typeof Stacked_Chart === 'boolean') {
		app.StackedChart = Stacked_Chart;
	}
	//console.log(app.StackedChart);
	
	// set draw correlogram or not to global variable
	if (typeof Correlogram !== 'undefined' && typeof Correlogram === 'boolean') {
		app.Correlogram = Correlogram;
	}
	//console.log(app.correlogram);
	
	// set draw scatter plot or not to global variable
	if (typeof Scatter_Plot !== 'undefined' && typeof Scatter_Plot === 'boolean') {
		app.ScatterPlot = Scatter_Plot;
	}
	//console.log(app.ScatterPlot);
	
	// set draw parallel coordinates plot or not to global variable
	if (typeof Parallel_Coordinates_Plot !== 'undefined' && typeof Parallel_Coordinates_Plot === 'boolean') {
		app.ParallelCoordinatesPlot = Parallel_Coordinates_Plot;
	}
	//console.log(app.ScatterPlot);
	
	// modify app.m to 2 when Scatter_Plot
	if (app.ScatterPlot) {
		app.m = 2;                                                       // must be 2 maps
	}
	
	// set <div id="mapN" ..> to mapContainer
	var html_maps = '';
	for (var i=0; i<app.m; i++) {
		//html_maps += '<div id="map'+i+'" class="mapArea"></div><div class="MapBetween"></div>';
		var html_map = '<div id="map'+i+'" class="mapArea"></div><div class="MapBetween"></div>';
		if (i == app.m - 1 && !app.ScatterPlot && !app.StackedChart)
			html_map = '<div id="map'+i+'" class="mapAreaLast"></div>';
		html_maps += html_map;
	}
	var html_Scatterchart = '<div id="Scatterchart" class="mapArea"></div><div class="MapBetween"></div>';
	if (!app.StackedChart) html_Scatterchart = '<div id="Scatterchart" class="mapAreaLast"></div>';
	if (app.ScatterPlot) html_maps += html_Scatterchart;
	if (app.StackedChart) html_maps += '<div id="map'+app.m+'" class="mapAreaLast"></div>';
	if (app.ParallelCoordinatesPlot) html_maps += '<div id="PCPchart" class="chartArea"></div>';
	$("#mapContainer").html(html_maps);
	//$("#chart_scatter").html("scatter plot");
	
	// set default layers for each map
	var selectedlayers = [];
	if (typeof InitialLayers !== 'undefined' && InitialLayers instanceof Array) {
		var n = InitialLayers.length;
		if (n > app.m) n = app.m;
		//for (var i=0; i<InitialLayers.length; i++) {
		for (var i=0; i<n; i++) {
			if (typeof InitialLayers[i] === 'string' && app.titdic[InitialLayers[i]] in CA.features[0].properties) 
				selectedlayers.push(InitialLayers[i]);
		}
	}
	app.layers = [];
	for (var i=0; i<app.m; i++) {
		var theLayer = (selectedlayers.length > i) ? selectedlayers[i] : "";
		if (theLayer == "") theLayer = app.titles[i+1];
		app.layers.push(theLayer);
	}
	if (app.m == 2) app.layers[2] = app.titles[0];
	app.firstDefinedLayers = app.layers.slice();                     // deep copy of array
	//console.log(app.layers);
	
	// set initial map center to global variable
	if (typeof Initial_map_center !== 'undefined' && Initial_map_center instanceof Array) {
		if (Initial_map_center.length == 2) app.InitialMapCenter = Initial_map_center;
	}
	//console.log(app.InitialMapCenter);
	
	// set initial map zoom level to global variable
	if (typeof Initial_map_zoom_level !== 'undefined' && typeof Initial_map_zoom_level === 'number') {
		if (Initial_map_zoom_level >= 1 && Initial_map_zoom_level <= 20) app.InitialMapZoomLevel = Initial_map_zoom_level;
	}
	//console.log(app.InitialMapZoomLevel);
	
	// set number of decimal places to global variable
	if (typeof Num_Of_Decimal_Places !== 'undefined' && typeof Num_Of_Decimal_Places === 'number') {
		app.NumOfDecimalPlaces = Num_Of_Decimal_Places;
	}
	//console.log(app.NumOfDecimalPlaces);
	
	// set map width and height to global variable
	if (typeof Map_width !== 'undefined' && typeof Map_width === 'string' && 
	    Map_width.substring(Map_width.length-2) == 'px' && $.isNumeric(Map_width.replace('px',''))) {
		if (Map_width.substring(0, Map_width.length-2) >= 350) {
			app.MapWidth = Map_width;
			app.ChartWidth = Map_width;
		}
	}
	if (typeof Map_height !== 'undefined' && typeof Map_height === 'string' && 
	    Map_height.substring(Map_height.length-2) == 'px' && $.isNumeric(Map_height.replace('px',''))) {
		if (Map_height.substring(0, Map_height.length-2) >= 300) {
			app.MapHeight = Map_height;
			app.ChartHeight = Map_height;
		}
	}
	//console.log(app.MapWidth, app.MapHeight);
	
	// set chart width and height to global variable
	if (typeof Chart_width !== 'undefined' && typeof Chart_width === 'string' && 
	    Chart_width.substring(Chart_width.length-2) == 'px' && $.isNumeric(Chart_width.replace('px',''))) {
		if (Chart_width.substring(0, Chart_width.length-2) >= 350) app.ChartWidth = Chart_width;
	}
	if (typeof Chart_height !== 'undefined' && typeof Chart_height === 'string' && 
	    Chart_height.substring(Chart_height.length-2) == 'px' && $.isNumeric(Chart_height.replace('px',''))) {
		if (Chart_height.substring(0, Chart_height.length-2) >= 300) app.ChartHeight = Chart_height;
	}
	//console.log(app.ChartWidth, app.ChartHeight);
	
	$("#correlogram").html("");
	var msec = CA.features.length;
	if (msec < 500) msec = 500;
	//if (msec > 3000)
	swal({
		title: "Please wait...",
		text: "Maps will be ready in "+(msec/1000).toFixed(1)+" seconds.",
		timer: msec,
		//timer: 10000,
		//onOpen: () => { swal.showLoading() },
		icon: "info",
		buttons: false,
	}).then((value) => {
		//console.log("Initiaize all maps ended in "+(msec/1000).toFixed(1)+" seconds.");
		setTimeout(function() {
			triggerStackedAreaChart();
			triggerCorrelogram();
			triggerScatterChart();
			triggerParcoords();
		}, 500);
	});

	setTimeout(function() { 
		setTimeout(function() { 
			draw_all_maps(); 
		}, 100); 
	}, 100); 
	
	$("#initFiveMaps").show();
	$("#submitForm").parent().hide();
	$("#ajaxBusy").hide();
	document.documentElement.scrollTop = 80;
	
	
	// redraw all five maps using received GeoJSON
	$("#initFiveMaps").click(function() {
		//console.log(getNow());
		//console.log(getNow(), "    ", "_Initialize_all_maps_button clicked");
		app.inputType = "_Initialize_all_maps_button clicked";       // ex) _Initialize_all_maps_button clicked
		
		$("#correlogram").html("");
		CA = app.receivedGeoJSON;
		app.selectedGeoJSON = app.receivedGeoJSON;
		var msec = CA.features.length;
		if (msec < 500) msec = 500;
		//if (msec > 3000)
		swal({
			title: "Please wait...",
			text: "Maps will be ready in "+(msec/1000).toFixed(1)+" seconds.",
			timer: msec,
			//timer: 10000,
			icon: "info",
			buttons: false,
		}).then((value) => {
			//console.log("Initiaize all maps ended in "+(msec/1000).toFixed(1)+" seconds.");
			setTimeout(function() {
				triggerStackedAreaChart();
				triggerCorrelogram();
				triggerScatterChart();
				triggerParcoords();
			}, 500);
		});

		setTimeout(function() { 
			setTimeout(function() { 
				draw_all_maps(); 
			}, 100); 
		}, 100);
	});
});


// check and draw stacked area chart
function triggerStackedAreaChart() {
	if ($("#map"+(app.m)).length == 0) return;
	console.log("triggerStackedAreaChart started.")
	//$("#map"+(app.m+1)).html("");
	if (app.StackedChart == false || app.m <= 1) {
		return;
	}
	$("#map"+(app.m)).html("");
	
	var zm = 1;
	if (!isAllzIntervalsEqual()) return;
	
	var dataGlobal = [];
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		//var row = {date: new Date(app.years[i], 1, 1)};
		var row = {mapId: (i+1)};                                    // map number (1, 2, ...)
		if (app[mapN].gPolygonbyClass[0] ==                          // skip if all are No Data
			app[mapN].gPolygonbyClass[app[mapN].gPolygonbyClass.length-1]) continue;    
		//console.log(mapN, 0, app[mapN].gPolygonbyClass[0], app[mapN].gPolygonbyClass.length, app[mapN].gPolygonbyClass[app[mapN].gPolygonbyClass.length-1],app[mapN].gPolygonbyClass);
		for (var j=1; j<app[mapN].gPolygonbyClass.length; j++) {
			var c = "class" + j;
			row[c] = app[mapN].gPolygonbyClass[j];
		}
		dataGlobal.push(row);
		//console.log(dataGlobal);
	}
	dataGlobal["columns"] = ["date"];
	for (var j=1; j<app["maps"].gPolygonbyClass.length; j++) {
		var c = "class" + j;
		dataGlobal["columns"].push(c);
	}
	//console.log(dataGlobal);		

	var dataLocal = [];
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		//var row = {date: new Date(app.years[i], 1, 1)};
		var row = {mapId: (i+1)};                                    // map number (1, 2, ...)
		if (app[mapN].nPolygonbyClass[0] ==                          // skip if all are No Data
			app[mapN].nPolygonbyClass[app[mapN].nPolygonbyClass.length-1]) continue;    
		//console.log(mapN, 0, app[mapN].nPolygonbyClass[0], app[mapN].nPolygonbyClass.length, app[mapN].nPolygonbyClass[app[mapN].nPolygonbyClass.length-1],app[mapN].nPolygonbyClass);
		for (var j=1; j<app[mapN].nPolygonbyClass.length; j++) {
			var c = "class" + j;
			row[c] = app[mapN].nPolygonbyClass[j];
		}
		dataLocal.push(row);
		//console.log(dataLocal);
	}
	dataLocal["columns"] = ["date"];
	for (var j=1; j<app["maps"].nPolygonbyClass.length; j++) {
		var c = "class" + j;
		dataLocal["columns"].push(c);
	}
	//console.log(dataLocal);		
	
	// ChartWidth: 500px, ChartHeight: 500px  ->  cWidth: 470, cHeight: 240
	var ChartWidth  = app.ChartWidth .replace('px','');
	var ChartHeight = app.ChartHeight.replace('px','');
	var cWidth  = ChartWidth - 30;
	var cHeight = Math.floor((ChartHeight - 20) / 2);
	//console.log("Chart: ("+ChartWidth+","+ChartHeight+")  ->  chart: ("+cWidth+","+cHeight+")");
	var html = '';
	//html += '<div style="text-align:center;">The percentage of polygons blelonging to each class</div>';
	html += '<div style="text-align:left;">&nbsp;<b>Stacked Area Chart</b></div>';
	html += '<div style="text-align:right; margin-top:15px;">';
	html += '	<div style="text-align:left; padding-left:70px; font-size:80%; font-style:normal;">Global</div>';
	html += '	<svg id="globalStackedAreaChart" width="' + cWidth + '" height="' + cHeight + '"></svg>';
	html += '</div>';
	html += '<div style="text-align:right; margin-top:10px;">';
	html += '	<div style="text-align:left; padding-left:70px; font-size:80%; font-style:normal;">Local</div>';
	html += '	<svg id="localStackedAreaChart" width="' + cWidth + '" height="' + cHeight + '"></svg>';
	html += '</div>';
	//$("#map"+(app.m+1)).html(html);
	$("#map"+(app.m)).html(html);
	drawStackedAreaChart("globalStackedAreaChart", dataGlobal, app.colorGradient19[0]);
	drawStackedAreaChart("localStackedAreaChart",  dataLocal,  app.colorGradient19[1]);
}


// draw all five maps when
//   1. when receive GeoJSON from server
//   2. when 'Initialize all maps' button clicked
function draw_all_maps() {

	// draw titles area
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		var map_html = '';
		map_html += '<div>';
		//map_html += '	<div class="map_layer" style="height:25px;"></div>';
		map_html += '	<div class="map_id" style="height:25px;float:left;clear:both"></div>';
		map_html += '	<div class="map_layer" style="height:25px;float:right"></div>';
		map_html += '</div>';
		map_html += '<div>';
		map_html += '	<div class="map_metroInterval" style="height:25px;float:left;clear:both"></div>';
		map_html += '	<div class="map_sync" style="height:25px;float:right"></div>';
		map_html += '</div>';
		map_html += '<div class="map"></div>';
		//console.log(i, map_html);
		document.getElementById(mapN).innerHTML = map_html;
	}
	
	if (app.ScatterPlot) {
		var map_html = '';
		map_html += '<div>';
		map_html += '	<div class="map_id" style="height:25px;float:left;clear:both"></div>';
		map_html += '	<div class="map_layer" style="height:25px;float:right"></div>';
		map_html += '</div>';
		map_html += '<div id="chart_scatter" class="mapArea" ' +
					'onmouseenter="mouseenterScatter(this)" onmouseleave="mouseleaveScatter(this)"></div>';
		document.getElementById("Scatterchart").innerHTML = map_html;
	}
	
	if (app.ParallelCoordinatesPlot) {
		var map_html = '';
		map_html += '<div>';
		map_html += '	<div class="map_id" style="height:25px;float:left;clear:both"></div>';
		map_html += '	<div class="map_layer" style="height:25px;float:right"></div>';
		map_html += '	<div class="map_fixAxes" style="margin-right:100px;height:25px;float:right"></div>';
		map_html += '</div>';
		map_html += '<div id="chart_ParallelCoordinates" class="chartArea" ' +
					'onmouseenter="mouseenterParallelCoordinates(this)" onmouseleave="mouseleaveParallelCoordinates(this)"></div>';
		document.getElementById("PCPchart").innerHTML = map_html;
	}
	
	// change height and width for maps and stacked area chart
	$("#mapContainer").css("height", app.MapHeight.replace('px','')*1+100+'px');
	$("#chart_scatter").css("height", app.MapHeight.replace('px','')*1+50+'px');
	var parcoords_width = 1500;
	if (parcoords_width < app.m * 200) parcoords_width = app.m * 200;
	if (parcoords_width > 2000) parcoords_width = 2000;
	$("#chart_ParallelCoordinates").css("width", parcoords_width+'px');
	$("#chart_ParallelCoordinates").css("height", app.MapHeight.replace('px','')*1+50+'px');
	$(".mapArea").css("width", app.MapWidth);
	$(".mapAreaLast").css("width", app.ChartWidth);
	$(".map").css("width", app.MapWidth);
	$(".map").css("height", app.MapHeight);
	
	$("#chart_scatter").on("contextmenu", function(e) {
		console.log(e)
		e.preventDefault();
		console.log("right click on the chart_scatter", app.map2.item)
		var map2 = "map2";
		var selectedLayer  = $("#Scatterchart select[name=ACSdata]").val();
		if (selectedLayer == "L000") {
			if (app[map2].item && app[map2].item != "L000") {
				$("#Scatterchart select[name=ACSdata]").val(app[map2].item);
				triggerScatterChart();
			}
		}
	});

	// draw each base map
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		draw_basemap(mapN);
	}

	// draw titles of each map
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		draw_titlemap(mapN, app.layers[i]);
	}
	
	// draw titles of Scatterchart
	draw_titleScatterchart();
	
	// draw titles of PCPchart
	draw_titlePCPchart();
	
	draw_globalSelection();

	// initialize all bounds in app.mapN
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		app[mapN].bounds = app[mapN].map.getBounds();
	}
	
	// set map bounds using geo bounds in d3 function
	var geoBounds = d3.geoBounds(CA);
	//console.log(geoBounds)
	//var fitBounds = L.latLngBounds(L.latLng(geoBounds[0][1], geoBounds[0][0]), 
	//							   L.latLng(geoBounds[1][1], geoBounds[1][0]));
	var north = geoBounds[1][1];
	var east  = geoBounds[1][0];
	var south = geoBounds[0][1];
	var west  = geoBounds[0][0];
	var w = (east - west) * app.adjustBound;							// default 0.25
	var h = (north - south) * app.adjustBound;							// default 0.25
	north -= h;
	south += h;
	west += w;
	east -= w;
	var fitBounds = L.latLngBounds(L.latLng(north, east), L.latLng(south, west));
	//console.log('fitBounds:', fitBounds);
	if (app.m > 0 && app.InitialMapCenter != null && app.InitialMapZoomLevel != null) {
	
		// set bitBounds from InitialMapCenter and InitialMapZoomLevel
		fitBounds = app[mapN].bounds;
		var mapBounds = app[mapN].map.getBounds();
		var west = mapBounds.getWest();
		var south = mapBounds.getSouth();
		var east = mapBounds.getEast();
		var north = mapBounds.getNorth();
		var featureMapBounds = {type: "Feature", properties: {}, geometry: {type: "Polygon", coordinates: [
			[ [west, south], [east, south], [east, north], [west, north], [west, south] ] 
		]}}

		// build selectedGeoJSON from receivedGeoJSON
		var count = 0, edgeCount = 0;
		var started = moment(new Date());
		var selectedFeatures = [];
		var count = 0;
		var baseLines = lineify(featureMapBounds);
		
		$.each(app.receivedGeoJSON.features, function(rIdx, feature) {
			if (isPolygonInMapBounds(feature, baseLines, west, south, east, north)) {
				count += 1;
				selectedFeatures.push([feature.properties[app.geokey], rIdx]);
			}
		});
		var duration = moment.duration(moment(new Date()).diff(started));
		//console.log(getNow(), mapN, 'selected features count in mapBounds: ' + count + /* '    edgeCount: ' + edgeCount + */ '    duration:', duration/1000);
		//console.log(selectedFeatures);
		
		// build selectedGeoJSON and set it to CA
		app.selectedGeoJSON = {"type":"FeatureCollection", "features":[]};
		$.each(selectedFeatures, function(rIdx, feature) {
			// feature[0] -> tractid, feature[1] -> rIdx
			app.selectedGeoJSON.features.push(app.receivedGeoJSON.features[feature[1]]);
		});
		CA = app.selectedGeoJSON;
		selectedFeatures = null;
		app.selectedBounds = mapBounds;
	}
	
	// fitBounds and redraw maps
	setTimeout(function () {
		// fitBounds
		var started = moment(new Date());
		var watchfitbounds = [false, false, false, false, false];
		for (i=0; i<app.m; i++) {
			var mapN = "map" + i;
			var alreadyFitted = false;
			if (boundsEqual(app[mapN].map.getBounds(), fitBounds)) alreadyFitted = true;
			else app[mapN].map.fitBounds(fitBounds);

			watchfitbounds[i] = setInterval(function(i, mapN) {
				var duration = moment.duration(moment(new Date()).diff(started));
				var nowBounds = app[mapN].map.getBounds();
				//console.log(getNow(), mapN, mapN+'.bounds:', app[mapN].bounds);
				//console.log(getNow(), mapN, 'nowBounds:', nowBounds, duration / 1000);
				if (alreadyFitted || !boundsEqual(app[mapN].bounds, nowBounds)) {
					//console.log(getNow(), mapN, 'after  fitBounds: ', nowBounds, 'duration:', duration/1000);
					clearInterval(watchfitbounds[i]);
					watchfitbounds[i] = false;
					app[mapN].bounds = nowBounds;
				}
				if (duration > 10000) {                              // 30000 = 30 sec
					//console.log(getNow(), mapN, 'ffit fitBounds incompleted: ', nowBounds, 'duration:', duration/1000);
					clearInterval(watchfitbounds[i]);
					watchfitbounds[i] = false;
				}
				if (!watchfitbounds.reduce(function(x, y) {return x || y;})) {
					//console.log(getNow(), mapN, 'ALL fit fitBounds completed: ', nowBounds, 'duration:', duration/1000);
					updateGloballyButton();
					app.selectedBounds = nowBounds;
					setTimeout(function() { mapOn_lasso_event_set(); }, 100);
					setTimeout(function() { mapOn_contextmenu_set(); }, 100);
					setTimeout(function() { mapOn_movestart_set(); }, 200);
					setTimeout(function() { mapOn_moveend_set(); }, 500);
				}
			}, 100, i, mapN);
		}
		
		// redraw maps
		for (var i=0; i<app.m; i++) {
			var mapN = "map" + i;
			//console.log(getNow(), mapN, 'drawing map started.');
			drawAmap(mapN, 3);
		}
	}, 100);
}


function fadeToWindow(mIDX) {
	if (!app.isFaded) {
		app.isFaded = true;
		app.fadeCount += 1;
		app.faded_at = moment(new Date());
		console.log(getNow(), mIDX, 'fadeToWindow start.', app.fadeCount);
		$(".backLayer").css({top:(window.pageYOffset || document.documentElement.scrollTop), position:'absolute'});
		$(".backLayer").width($(window).width()).height($(window).height());
		$(".backLayer").fadeTo(300, 0.3);
	} else {
		console.log(getNow(), mIDX, 'fadeToWindow start ignored.', app.fadeCount);
	}
}

function fadeOutWindow(mIDX) {
	if (app.isFaded) {
		app.isFaded = false;
		var duration = moment.duration(moment(new Date()).diff(app.faded_at));
		console.log(getNow(), mIDX, 'fadeOutWindow ended.', app.fadeCount, 'duration:', duration/1000);
		$(".backLayer").fadeOut(300);
	} else {
		console.log(getNow(), mIDX, 'fadeOutWindow ended ignored.', app.fadeCount);
	}
}


function mapOn_lasso_event_set() {
	if (app.ScatterPlot == false && app.ParallelCoordinatesPlot == false) return;
	j = null;
	for (i=0; i<app.m; i++) {
		var mIDX = "map" + i;
		
		app[mIDX].map.on('lasso.finished', event => {
			var layer = event.target;
			var sIDX = layer.getContainer().parentNode.id;
			console.log("mIDX:", mIDX, "sIDX:", sIDX)                // mIDX == sIDX ???
			//console.log(sIDX, "lasso.finished:", $("#"+sIDX+" .leaflet-control-lasso").css('background-color'), event)
			var preColor = $("#"+sIDX+" .leaflet-control-lasso").css('background-color');
			console.log(sIDX, "lasso.finished:", RGBdict[preColor], event)
			if (preColor == RGBpink) {
				//resetSytle(app.sPointsMaps);
				resetSytlefromLassoselect(app.sPointsMaps);
				app.sPointsMaps = [];
				if (event.layers.length != 0) {
					for (var i=0; i<event.layers.length; i++) {
						var layer = event.layers[i];
						//console.log(i, layer);
						//if (!layer) continue;
						//var layerid = (layer.hasOwnProperty('_leaflet_id')) ? layer._leaflet_id : '';
						var layerid = layer._leaflet_id;
						var geokey = layer.feature.properties[app.geokey];
						//console.log(sIDX, "layerid:", layerid, "geokey:", geokey);
						app.sPointsMaps.push(geokey);
					}
					console.log(sIDX, app.sPointsMaps);
					$("#"+sIDX+" .leaflet-control-lasso").css('background-color',RGBfuchsia);
					app.isLassoPushed = true;
				}
				if (event.layers.length == 0) {
					$("#"+sIDX+" .leaflet-control-lasso").css('background-color',RGBwhite);
					app.isLassoPushed = false;
					triggerScatterChart();
					triggerParcoords();
				}
				//setSytleHighlight(app.sPointsMaps, sIDX);
				setSytleHighlightfromLassoselect(app.sPointsMaps, sIDX);
				//paintScatter(map0="map0", map1="map1", {lassoData="", eventData=""}={}) {;
				//// here !!
				//$("#"+sIDX+" select[name=ACSdata]").val();
				//$("#PCPchart select[name=ACSdata]").val($("#"+sIDX+" select[name=ACSdata]").val());
				////$("#map2 select[name=ACSdata]").val("L000");
				app.sPointsParcoords = [];
				$("#Scatterchart select[name=ACSdata]").val("L000");
				paintScatter('map0', 'map1', {lassoData:app.sPointsMaps});
				paintParcoords({lassoData:app.sPointsMaps, lassoedMap:sIDX});
			}
		});
		
		app[mIDX].map.on('lasso.enabled', event => {     // pause on click event
			//console.log(mIDX, "lasso.enabled:", event)
			var layer = event.target;
			var sIDX = layer.getContainer().parentNode.id;
			//console.log("mIDX:", mIDX, "sIDX:", sIDX)                // mIDX == sIDX ???
			//console.log(sIDX, "lasso.enabled:", $("#"+sIDX+" .leaflet-control-lasso").css('background-color'), event)
			var preColor = $("#"+sIDX+" .leaflet-control-lasso").css('background-color');
			console.log(sIDX, "lasso.enabled:", RGBdict[preColor], event)
			if (preColor == RGBwhite) {
				for (var i=0; i<app.m; i++) {
					var mapN = "map" + i;
					if (sIDX == mapN) continue;
					if (app[mapN].lasso) app[mapN].lasso.enable();
					//$("#"+mapN+" .leaflet-control-lasso").hide();
				}
			}
			if (preColor == RGBwhite) {
				$("#"+sIDX+" .leaflet-control-lasso").css('background-color',RGBpink);
				app.isLassoPushed = true;
			}
			if (preColor == RGBpink) {
				//$("#"+sIDX+" .leaflet-control-lasso").css('background-color',RGBpink);
				//app.isLassoPushed = true;
			}
		});
		
		app[mIDX].map.on('lasso.disabled', event => {    // restart on click event
			var layer = event.target;
			var sIDX = layer.getContainer().parentNode.id;
			var preColor = $("#"+sIDX+" .leaflet-control-lasso").css('background-color');
			console.log(sIDX, "lasso.disabled:", RGBdict[preColor], event)
			if (preColor == RGBwhite || preColor == RGBpink) {
				for (var i=0; i<app.m; i++) {
					var mapN = "map" + i;
					if (sIDX == mapN) continue;
					if (app[mapN].lasso) app[mapN].lasso.disable();
					//$("#"+mapN+" .leaflet-control-lasso").show();
				}
				//resetSytle(app.sPointsMaps);
				if (app.sPointsMaps.length > 0) {
					console.log("app.sPointsMaps:", app.sPointsMaps)
					resetSytlefromLassoselect(app.sPointsMaps);
					app.sPointsMaps = [];
					triggerScatterChart();
					triggerParcoords();
				}
			}
			if (preColor == RGBpink) {
				$("#"+sIDX+" .leaflet-control-lasso").css('background-color',RGBwhite);
				app.isLassoPushed = false;
				//triggerParcoords();
			}
			if (preColor == RGBfuchsia) {
				$("#"+sIDX+" .leaflet-control-lasso").css('background-color',RGBpink);
				//app.isLassoPushed = true;
				app[sIDX].lasso.enable();
			}
		});
	}
}

function mapOn_contextmenu_set(mIDX) {
	var pIDX = (mIDX) ? mIDX : "    "
	//console.log(getNow(), pIDX, 'START mapOn_contextmenu_set');

	if (app.m >= 1  && (pIDX == "    " || pIDX == "map0" )) app["map0" ].map.on('contextmenu', mapON_contextmenu_map0, "map60");
	if (app.m >= 2  && (pIDX == "    " || pIDX == "map1" )) app["map1" ].map.on('contextmenu', mapON_contextmenu_map1, "map61");
	if (app.m >= 3  && (pIDX == "    " || pIDX == "map2" )) app["map2" ].map.on('contextmenu', mapON_contextmenu_map2, "map62");
	if (app.m >= 4  && (pIDX == "    " || pIDX == "map3" )) app["map3" ].map.on('contextmenu', mapON_contextmenu_map3, "map63");
	if (app.m >= 5  && (pIDX == "    " || pIDX == "map4" )) app["map4" ].map.on('contextmenu', mapON_contextmenu_map4, "map64");
	if (app.m >= 6  && (pIDX == "    " || pIDX == "map5" )) app["map5" ].map.on('contextmenu', mapON_contextmenu_map5, "map65");
	if (app.m >= 7  && (pIDX == "    " || pIDX == "map6" )) app["map6" ].map.on('contextmenu', mapON_contextmenu_map6, "map66");
	if (app.m >= 8  && (pIDX == "    " || pIDX == "map7" )) app["map7" ].map.on('contextmenu', mapON_contextmenu_map7, "map67");
	if (app.m >= 9  && (pIDX == "    " || pIDX == "map8" )) app["map8" ].map.on('contextmenu', mapON_contextmenu_map8, "map68");
	if (app.m >= 10 && (pIDX == "    " || pIDX == "map9" )) app["map9" ].map.on('contextmenu', mapON_contextmenu_map9, "map69");
	if (app.m >= 11 && (pIDX == "    " || pIDX == "map10")) app["map10"].map.on('contextmenu', mapON_contextmenu_map10,"map70");
	if (app.m >= 12 && (pIDX == "    " || pIDX == "map11")) app["map11"].map.on('contextmenu', mapON_contextmenu_map11,"map71");
	if (app.m >= 13 && (pIDX == "    " || pIDX == "map12")) app["map12"].map.on('contextmenu', mapON_contextmenu_map12,"map72");
	if (app.m >= 14 && (pIDX == "    " || pIDX == "map13")) app["map13"].map.on('contextmenu', mapON_contextmenu_map13,"map73");
	if (app.m >= 15 && (pIDX == "    " || pIDX == "map14")) app["map14"].map.on('contextmenu', mapON_contextmenu_map14,"map74");

	//console.log(getNow(), pIDX, 'ENDED mapOn_contextmenu_set');
}

function mapON_contextmenu_map0(e)  { mapON_contextmenu(e, "map0" ); }
function mapON_contextmenu_map1(e)  { mapON_contextmenu(e, "map1" ); }
function mapON_contextmenu_map2(e)  { mapON_contextmenu(e, "map2" ); }
function mapON_contextmenu_map3(e)  { mapON_contextmenu(e, "map3" ); }
function mapON_contextmenu_map4(e)  { mapON_contextmenu(e, "map4" ); }
function mapON_contextmenu_map5(e)  { mapON_contextmenu(e, "map5" ); }
function mapON_contextmenu_map6(e)  { mapON_contextmenu(e, "map6" ); }
function mapON_contextmenu_map7(e)  { mapON_contextmenu(e, "map7" ); }
function mapON_contextmenu_map8(e)  { mapON_contextmenu(e, "map8" ); }
function mapON_contextmenu_map9(e)  { mapON_contextmenu(e, "map9" ); }
function mapON_contextmenu_map10(e) { mapON_contextmenu(e, "map10"); }
function mapON_contextmenu_map11(e) { mapON_contextmenu(e, "map11"); }
function mapON_contextmenu_map12(e) { mapON_contextmenu(e, "map12"); }
function mapON_contextmenu_map13(e) { mapON_contextmenu(e, "map13"); }
function mapON_contextmenu_map14(e) { mapON_contextmenu(e, "map14"); }

function mapON_contextmenu(e, mIDX) {
	//console.log(getNow(), mIDX, mIDX+"_contextmenu clicked");
	app.inputType = mIDX+"_contextmenu clicked";                     // ex) map0_contextmenu clicked
	globalHeadingRestore();
	
	// changed metroInterval type from checkbox to radio button
	var GorL = $('input[type=radio][name="'+mIDX+'-checkbox"]:checked').val();
	if (GorL == "Global") {
		$('input[type=radio][name="'+mIDX+'-checkbox"]:input[value="Local"]').prop("checked", true);
	} else {
		$('input[type=radio][name="'+mIDX+'-checkbox"]:input[value="Global"]').prop("checked", true);
	}
	
	var nowBounds = app[mIDX].map.getBounds();
	if (!boundsEqual(app.selectedBounds, nowBounds)) {
		//console.log(getNow(), mIDX, 'mIDX.map.getBounds() != app.selectedBounds', nowBounds, app.selectedBounds);
		app.selectedBounds = nowBounds;
		updateSelectedGeoJSON(mIDX);
		CA = app.selectedGeoJSON;
	}
	ACSdata_render(mIDX);
}

var mapON_movestarts = [
	function mapON_movestart_map0 (e) { mapON_movestart(e, "map0" ); },
	function mapON_movestart_map1 (e) { mapON_movestart(e, "map1" ); },
	function mapON_movestart_map2 (e) { mapON_movestart(e, "map2" ); },
	function mapON_movestart_map3 (e) { mapON_movestart(e, "map3" ); },
	function mapON_movestart_map4 (e) { mapON_movestart(e, "map4" ); },
	function mapON_movestart_map5 (e) { mapON_movestart(e, "map5" ); },
	function mapON_movestart_map6 (e) { mapON_movestart(e, "map6" ); },
	function mapON_movestart_map7 (e) { mapON_movestart(e, "map7" ); },
	function mapON_movestart_map8 (e) { mapON_movestart(e, "map8" ); },
	function mapON_movestart_map9 (e) { mapON_movestart(e, "map9" ); },
	function mapON_movestart_map10(e) { mapON_movestart(e, "map10"); },
	function mapON_movestart_map11(e) { mapON_movestart(e, "map11"); },
	function mapON_movestart_map12(e) { mapON_movestart(e, "map12"); },
	function mapON_movestart_map13(e) { mapON_movestart(e, "map13"); },
	function mapON_movestart_map14(e) { mapON_movestart(e, "map14"); },
];

function mapOn_movestart_set(mIDX) {
	var pIDX = (mIDX) ? mIDX : "    "
	for (i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (count_movestart_event(mapN) == 0 && (pIDX == "    " || pIDX == mapN))
			app[mapN].map.on('movestart', mapON_movestarts[i], mapN);
	}
}

function mapOn_movestart_off(mIDX) {
	var pIDX = (mIDX) ? mIDX : "    "
	for (i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (count_movestart_event(mapN) != 0 && (pIDX == "    " || pIDX == mapN))
			app[mapN].map.off('movestart', mapON_movestarts[i], mapN);
	}
}

function mapON_movestart(e, mIDX) {
	//console.log(getNow(), mIDX, mIDX+"_event_movestart detected");
	app.inputType = mIDX+"_event_movestart detected";                // ex) map0_event_movestart detected
	fadeToWindow(mIDX);
	mapOn_movestart_off();
}

var mapON_moveends = [
	function mapON_moveend_map0 (e) { mapON_moveend(e, "map0" ); },
	function mapON_moveend_map1 (e) { mapON_moveend(e, "map1" ); },
	function mapON_moveend_map2 (e) { mapON_moveend(e, "map2" ); },
	function mapON_moveend_map3 (e) { mapON_moveend(e, "map3" ); },
	function mapON_moveend_map4 (e) { mapON_moveend(e, "map4" ); },
	function mapON_moveend_map5 (e) { mapON_moveend(e, "map5" ); },
	function mapON_moveend_map6 (e) { mapON_moveend(e, "map6" ); },
	function mapON_moveend_map7 (e) { mapON_moveend(e, "map7" ); },
	function mapON_moveend_map8 (e) { mapON_moveend(e, "map8" ); },
	function mapON_moveend_map9 (e) { mapON_moveend(e, "map9" ); },
	function mapON_moveend_map10(e) { mapON_moveend(e, "map10"); },
	function mapON_moveend_map11(e) { mapON_moveend(e, "map11"); },
	function mapON_moveend_map12(e) { mapON_moveend(e, "map12"); },
	function mapON_moveend_map13(e) { mapON_moveend(e, "map13"); },
	function mapON_moveend_map14(e) { mapON_moveend(e, "map14"); },
];

function mapOn_moveend_set(mIDX) {
	var pIDX = (mIDX) ? mIDX : "    "
	for (i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (count_moveend_event(mapN) == 0 && (pIDX == "    " || pIDX == mapN))
			app[mapN].map.on('moveend', mapON_moveends[i], mapN);
	}
}

function mapOn_moveend_off(mIDX) {
	var pIDX = (mIDX) ? mIDX : "    "
	for (i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (count_moveend_event(mapN) != 0 && (pIDX == "    " || pIDX == mapN))
			app[mapN].map.off('moveend', mapON_moveends[i], mapN);
	}
}

function mapON_moveend(e, mIDX) { 
	//console.log(getNow(), mIDX, mIDX+"_event_moveend detected");
	app.inputType = mIDX+"_event_moveend detected";                  // ex) map0_event_moveend detected
	globalHeadingRestore();
	mapOn_moveend_off();
	setTimeout(function() { 
		redraw_maps(mIDX, 1);
	}, 100);
};

// count 'movestart' event registered in the map 
function count_movestart_event(mIDX, e) {
	var movestartEvents = app[mIDX].map._events["movestart"];
	if (e) movestartEvents = e.target._events["movestart"];
	if (!movestartEvents) return 0;
	var count = 0;
	$.each(movestartEvents, function(idx, row) {
		var ctx = row['ctx'];
		//console.log(mIDX, idx, ctx, e);
		if (typeof ctx === 'string' && ctx.startsWith(mIDX)) count += 1;
	});
	return count;
}

// count 'moveend' event registered in the map 
function count_moveend_event(mIDX, e) {
	var moveendEvents = app[mIDX].map._events["moveend"];
	if (e) moveendEvents = e.target._events["moveend"];
	if (!moveendEvents) return 0;
	var count = 0;
	$.each(moveendEvents, function(idx, row) {
		var ctx = row['ctx'];
		//console.log(getNow(), mIDX, idx, ctx, e);
		if (typeof ctx === 'string' && ctx.startsWith(mIDX)) count += 1;
	});
	return count;
}


// call 'redraw_all_maps' and check it completed.
function redraw_maps(mIDX, drawMode, baseBounds) {
	redraw_all_maps(mIDX, drawMode, baseBounds);
	
	$("#correlogram").html("");
	var started = moment(new Date());
	//console.log(getNow(), mIDX, 'after  redraw_all_maps');
	var i = 0;
	function repeat_setTimeout() {
		setTimeout(function() {
			i += 1;
			if (i > 70) {
				var duration = moment.duration(moment(new Date()).diff(started));
				//console.log(getNow(), mIDX, 'after  redraw_all_maps:', (i-1), ' duration:', duration/1000);
				updateGloballyButton();
				mapOn_movestart_set();
				mapOn_moveend_set();
				setTimeout(function() {
					triggerStackedAreaChart();
					triggerCorrelogram();
					triggerScatterChart();
					triggerParcoords();
				}, 500);
				//console.log(getNow(), mIDX, 'fadeOutWindow ended.');
				fadeOutWindow(mIDX);
			} else {
				repeat_setTimeout();
			}
		}, 0);
	}
	repeat_setTimeout();
}

// redraw a map and related maps
function redraw_all_maps(mIDX, drawMode, baseBounds) {
	
	// drawMode ->  1: draw normal,  2: draw when auto, manual selected,  3: draw all maps force
	//console.log(getNow(), mIDX, 'redraw_maps start', 'drawMode: ', drawMode, 'baseBounds: ', baseBounds);
	
	var prvBounds = app[mIDX].bounds;
	var mapBounds = app[mIDX].map.getBounds();
	app[mIDX].bounds = mapBounds;                                    // save this map bounds to app.mapN.bounds
	if (baseBounds) mapBounds = baseBounds;                          // auto clicked, Join group aleady existed
	
	//console.log(getNow(), mIDX, 'prvBounds: ', prvBounds);
	//console.log(getNow(), mIDX, 'mapBounds: ', mapBounds);
	
	var west = mapBounds.getWest();
	var south = mapBounds.getSouth();
	var east = mapBounds.getEast();
	var north = mapBounds.getNorth();
	var featureMapBounds = {type: "Feature", properties: {}, geometry: {type: "Polygon", coordinates: [
		[ [west, south], [east, south], [east, north], [west, north], [west, south] ] 
	]}}
	
	// build selectedGeoJSON from receivedGeoJSON
	var count = 0;
	var selectedFeatures = [];
	var baseLines = lineify(featureMapBounds);
	
	var started = moment(new Date());
	$.each(app.receivedGeoJSON.features, function(rIdx, feature) {
		if (isPolygonInMapBounds(feature, baseLines, west, south, east, north)) {
			count += 1;
			selectedFeatures.push([feature.properties[app.geokey], rIdx]);
		}
	});
	var duration = moment.duration(moment(new Date()).diff(started));
	//console.log(getNow(), mIDX, 'selected features count in mapBounds:', count, '    duration:', duration/1000);

	var this_sync = $('input[type=radio][name="'+mIDX+'-radio"]:checked').val();
	
	// determine witch maps need to fitBounds
	var refitBoundableMaps = (!boundsEqual(mapBounds, app[mIDX].map.getBounds())) ? [mIDX] : [];
	for (i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (mapN == mIDX) continue;
		var that_sync = $('input[type=radio][name="'+mapN+'-radio"]:checked').val();
		if (drawMode != 3) {
			if (this_sync == 'auto' && that_sync == 'manual') continue;
			if (this_sync == 'manual') continue;
		}
		//console.log(boundsEqual(mapBounds, app[mapN].map.getBounds()), mapBounds, app[mapN].map.getBounds())
		if (!boundsEqual(mapBounds, app[mapN].map.getBounds())) {
			refitBoundableMaps.push(mapN);
		}
	}
	//console.log(refitBoundableMaps)
	
	// check need redrawing or not
	var needDrawing = true;
	if (drawMode == 1 && count < 1) {        // 10  ->  1
		//console.log(getNow(), mIDX, 'redrawing map ignored when count < 1');
		needDrawing = false;
	}
	
	if (selectedFeatures.length == CA.features.length) {
		var isEqual = true;
		for (f=0; f<selectedFeatures.length; f++) {
			var prvFeature = CA.features[f];
			var newFeature = selectedFeatures[f];
			if (newFeature[0] != prvFeature.properties.tractid) {
				isEqual = false;
				break;
			}
		}
		if (drawMode == 1 && isEqual) {
			//console.log(getNow(), mIDX, 'redrawing map ignored when prvGeoJSON = selectedFeatures');
			needDrawing = false;
		}
	}
	
	// determine witch maps need to redraw
	var redrawableMaps = [mIDX];
	var autoCount = (this_sync == 'auto') ? 1 : 0;
	for (i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (mapN == mIDX) continue;
		var that_sync = $('input[type=radio][name="'+mapN+'-radio"]:checked').val();
		if (that_sync == 'auto') autoCount += 1;
		var needRedraw = false;
		if (drawMode == 1 && this_sync == 'auto' && that_sync == 'auto') needRedraw = true;
		if (drawMode == 2 && that_sync == 'auto') needRedraw = true;
		if (drawMode == 3) needRedraw = true;
		if (needRedraw) redrawableMaps.push(mapN);
	}
	if (drawMode == 2 && this_sync == 'auto' && redrawableMaps.length == 1) redrawableMaps = [];
	//console.log(getNow(), mIDX, 'redrawableMaps', redrawableMaps);

	// build redraw decison table
	var fitBoundDT = [];  for (i=0; i<app.m; i++) fitBoundDT.push("    ");
	var drawMapsDT = [];  for (i=0; i<app.m; i++) drawMapsDT.push("    ");
	for (i=0; i<refitBoundableMaps.length; i++) 
		fitBoundDT[refitBoundableMaps[i].replace('map','')] = refitBoundableMaps[i];
	if (needDrawing)
	for (i=0; i<redrawableMaps.length; i++) 
		drawMapsDT[redrawableMaps[i].replace('map','')] = redrawableMaps[i];
	//console.log(getNow(), mIDX, 'fitBoundDT: ', fitBoundDT);
	//console.log(getNow(), mIDX, 'drawMapsDT: ', drawMapsDT);
	
	// re arrange decison table
	var c = mIDX.replace('map','');
	var fitBoundST = [fitBoundDT[c]];
	var drawMapsST = [drawMapsDT[c]];
	for (i=0; i<app.m; i++) {
		if (i != c) {
			fitBoundST.push(fitBoundDT[i]);
			drawMapsST.push(drawMapsDT[i]);
		}
	}
	//console.log(getNow(), mIDX, 'fitBoundST: ', fitBoundST);
	//console.log(getNow(), mIDX, 'drawMapsST: ', drawMapsST);
	
	if (needDrawing) {
		// build selectedGeoJSON
		app.selectedGeoJSON = {"type":"FeatureCollection", "features":[]};
		$.each(selectedFeatures, function(rIdx, feature) {
			app.selectedGeoJSON.features.push(app.receivedGeoJSON.features[feature[1]]);
		});
		CA = app.selectedGeoJSON;
		selectedFeatures = null;
		app.selectedBounds = mapBounds;
	}
	//console.log(CA);
	
	var mapN;
	for (var i=0; i<app.m; i++) {
		// fitBounds 
		mapN = fitBoundST[i];
		if (mapN != "    ") {
			//console.log(getNow(), mapN, 'fit mapBounds: ', mapBounds);
			app[mapN].map.fitBounds(mapBounds);
		}
		// redraw maps
		mapN = drawMapsST[i];
		if (mapN != "    ") {
			//console.log(getNow(), mapN, 'drawing map started.');
			drawAmap(mapN, drawMode);
		}
	}
}


// update global variable of selectedJSON from app.mapN.geojson.eachLayer
function updateSelectedGeoJSON(mIDX) {
	app.selectedGeoJSON = {"type":"FeatureCollection", "features":[]};
	app[mIDX].geojson.eachLayer(function(layer) {
		app.selectedGeoJSON.features.push(layer.feature);
	})
}


// Pading a value with leading zeors
// from stack overflow CMS answered Jun 8 '10 at 15:39 by Christian C. SalvadÃ³ in Guatemala, Central America
// https://stackoverflow.com/questions/2998784/how-to-output-integers-with-leading-zeros-in-javascript 
function zeroPad(num, places) {
  var zero = places - num.toString().length + 1;
  return Array(+(zero > 0 && zero)).join("0") + num;
}


// Draw Stacked Area Chart
function drawStackedAreaChart(svgid, data, colorGradient) {
	if (app.StackedChart == false || app.m <= 1) {
		//$("#map"+(app.m+1)).html("");
		return;
	}

	var clone = JSON.parse(JSON.stringify(data));          // deep copy from data
	
	var svg = d3.select("#"+svgid),
		margin = {top: 10, right: 20, bottom: 20, left: 40},
		width = svg.attr("width") - margin.left - margin.right,
		height = svg.attr("height") - margin.top - margin.bottom;
	
	var xAxis = {domain: [], range: []};
	for (var i=0; i<data.length; i++) {
		if (data.length <= 10) xAxis.domain.push('Map'+data[i].mapId);
		else xAxis.domain.push(data[i].mapId);
		xAxis.range.push(width*i*1.0/(data.length-1));
	}
	
	var ordinalScale = d3.scaleOrdinal().domain(xAxis.domain).range(xAxis.range),
	//	x = d3.scaleLinear().range([0, width]),
		x = d3.scaleTime().range([0, width]),
		y = d3.scaleLinear().range([height, 0]),
		z = d3.scaleOrdinal().range(colorGradient);
	
	var stack = d3.stack();
	
	var area = d3.area()
		.x(function(d, i) { return x(d.data.mapId); })
		.y0(function(d) { return y(d[0]); })
		.y1(function(d) { return y(d[1]); });
	
	var g = svg.append("g")
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	
	var keys = data.columns.slice(1);

	// convert value to percent
	for (var i=0; i<data.length; i++) {
		var t = 0;
		for (var j=0; j<keys.length; j++) {
			var k = keys[j];
			t += data[i][k];
		}
		for (var j=0; j<keys.length; j++) {
			var k = keys[j];
			data[i][k] = data[i][k] / t;
		}
	}
	//console.log(data);
	
	x.domain(d3.extent(data, function(d) { return d.mapId; }));
	z.domain(keys);
	stack.keys(keys);
	
	var layer = g.selectAll(".layer")
		.data(stack(data))
		.enter().append("g")
		.attr("class", "layer");
	
	layer.append("path")
		.attr("class", "stackedArea")
		.style("fill", function(d) { return z(d.key); })
		.attr("d", area);
	
	layer.filter(function(d) { return d[d.length - 1][1] - d[d.length - 1][0] > 0.01; })
		.append("text")
		.attr("x", width - 6)
		.attr("y", function(d) { return y((d[d.length - 1][0] + d[d.length - 1][1]) / 2); })
		.attr("dy", ".35em")
		.style("font", "10px sans-serif")
		.style("text-anchor", "end")
		.text(function(d) { return d.key.substring(0,d.key.length-1)+" "+d.key.substring(d.key.length-1); });
	
	g.append("g")
		.attr("class", "axis axis--x")
		.attr("transform", "translate(0," + height + ")")
		.call(d3.axisBottom(ordinalScale).ticks(data.length));
	
	g.append("g")
		.attr("class", "axis axis--y")
		.call(d3.axisLeft(y).ticks(5, "%"));
	
	// Prep the tooltip bits, initial display is hidden
    var tooltip = svg.append("g")
		.attr("class", "tooltip")
		.style("opacity", 1.0)
		.style("display", "none");

	tooltip.append("rect")
		.attr("width", 120)
		.attr("height", 20)
		.attr("fill", "white")
		.style("opacity", 0.5);
	
	tooltip.append("text")
		.attr("x", 60)
		.attr("dy", "1.2em")
		.style("text-anchor", "middle")
		.attr("font-size", "12px")
		.attr("font-weight", "bold");

}


// disable lasso button for all maps
function initializeLassoButtons(sIDX="map0") {
	var preColor = $("#"+sIDX+" .leaflet-control-lasso").css('background-color');
	//if (preColor && preColor == RGBpink) app[sIDX].lasso.disable();	   // initialize lasso button of all maps
	if (preColor && preColor == RGBpink) {
		resetSytlefromLassoselect(app.sPointsMaps);
		app.sPointsMaps = [];
		app[sIDX].lasso.disable();
	}
}

function triggerParcoords() {
	initializeLassoButtons();
	if ($('#PCPchart').length == 0) return;
	
	console.log(getNow(), 'triggerParcoords started.  ', app.inputType);
	console.log(getNow(), 'triggerParcoords started.  ', app.inputType);
	console.log(getNow(), 'triggerParcoords started.  ', app.inputType);
	console.log(getNow(), 'triggerParcoords started.  ', app.inputType);
	console.log(getNow(), 'triggerParcoords started.  ', app.inputType);
	var globalJoin = $('input[type=checkbox][id="globalJoin"]').is(":checked");
	var GorL = null;
	paintParcoords({globalJoin:globalJoin});
	
	// http://keith-wood.name/svg.html
	//$('#chart_ParallelCoordinates .axis-title').css("color", "red");    xxx
	
	//$(document.body).on('click','#chart_ParallelCoordinates .axis-heading', function() {
	//	var layer = $(this).text();
	//	console.log($(this).text());
	//	console.log("layer:", layer);
	//	if (app.titdic.hasOwnProperty(layer)) {
	//		$("#PCPchart select[name=ACSdata]").val(app.titdic[layer]);
	//		triggerParcoords();
	//		//var item = $("#"+mapN+" select[name=ACSdata]").val();
	//		//var layer = $("#"+mapN+" select[name=ACSdata]").find("option:selected").text();
	//	}
	//});
}

function redrawParcoords() {
	initializeLassoButtons();
	console.log(getNow(), 'redrawParcoords started.  ', app.inputType);
	console.log(getNow(), 'redrawParcoords started.  ', app.inputType);
	console.log(getNow(), 'redrawParcoords started.  ', app.inputType);
	console.log(getNow(), 'redrawParcoords started.  ', app.inputType);
	console.log(getNow(), 'redrawParcoords started.  ', app.inputType);
	var globalJoin = null;
	var GorL = null;
	//$("#map2 select[name=ACSdata]").val("L000");
	paintParcoords({globalJoin:globalJoin});
}

function paintParcoords({lassoData="", lassoedMap="", eventData="", globalJoin=null}={}) {
	console.log("lassoData:", '"'+lassoData+'"', lassoData);
	console.log("eventData:", '"'+eventData+'"', eventData);
	console.log("globalJoin:", globalJoin);
	
	var divPCP = document.getElementById('chart_ParallelCoordinates');
	var sameBounds = isAllBoundsEqual();
	//fadeToWindow("chart_ParallelCoordinates")
	Plotly.purge(divPCP);
	//$("#chart_ParallelCoordinates").html('');
	divPCP.innerHTML = '';
	if (!sameBounds) {
		var html = '';
		html += '<div style="padding:60px 50px; color:blue">';
		html += '<i>';
		html += 'This scatter chart is shown only when all maps have the same extent.<br><br>';
		html += '"Sync", "Join group" and "Grouping All" can be used to make maps have the same extent.';
		html += '</i>';
		html += '</div>';
		//$("#chart_ParallelCoordinates").html(html);
		divPCP.innerHTML = html;
		return;
	}
	
	var items = [];
	var layers = [];
	var array = [];
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		var item = $("#"+mapN+" select[name=ACSdata]").val();
		var layer = $("#"+mapN+" select[name=ACSdata]").find("option:selected").text();
		items.push(item);
		layers.push(layer);
		array.push([]);
	}
	console.log("items:", items);
	console.log("layers:", layers);
	
	var geoid = [];
	var selectedItem = $("#PCPchart select[name=ACSdata]").val();
	//// need to recalculation of intervals for selectedItem
	var classification = $("#global_class select[name=globalClass]").val();
	var nClass = $("#global_count select[name=globalCount]").val();
	//var i = $("#PCPchart select[name=ACSdata]").find("option:selected").index();
	//console.log("map" + i);
	//var mIDX = "map" + i;
	var mIDX = null;
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		var item = $("#"+mapN+" select[name=ACSdata]").val();
		if (item == selectedItem) mIDX = "map" + i;
	}
	//var intervals = app[mIDX].zIntervals;
	var intervals = geostats_classification(classification, nClass, CA, [selectedItem]);
	console.log("selectedItem:", selectedItem);
	console.log(mIDX, "intervals:", intervals);
	
	var classid = [];
	var dict = {};
	var maxValue = Number.MIN_VALUE;
	var minValue = Number.MAX_VALUE;
	var geoJSON = (sameBounds) ? app.selectedGeoJSON : app.receivedGeoJSON;    // always app.selectedGeoJSON ??
	for (var i=0; i<geoJSON.features.length; i++) {
		var row = geoJSON.features[i].properties;
		if (!row.hasOwnProperty(app.geokey)) continue;
		var isValidRow = true;
		for (var j=0; j<items.length; j++) {
			var item = items[j];
			if (!row.hasOwnProperty(item) || row[item] == -9999) isValidRow = false;
		}
		if (!isValidRow) continue;
		geoid.push(row[app.geokey])
		var cID = getClassID(row[selectedItem], intervals);
		//console.log(i, cID, row[selectedItem])
		classid.push(getClassID(row[selectedItem], intervals));
		var values = [i];
		for (var j=0; j<items.length; j++) {
			var item = items[j];
			array[j].push(row[item]);						// Number(row[item].toFixed(app.NumOfDecimalPlaces))
			values.push(row[item]);
			if (maxValue < row[item]) maxValue = row[item];
			if (minValue > row[item]) minValue = row[item];
		}
		dict[row[app.geokey]] = values;
	}
	console.log("geoJSON:", geoJSON)
	console.log("geoid:", geoid)
	console.log("classid:", classid)
	console.log("array:", array)
	console.log("dict:", dict)
	
	var ranges = new Array(app.m).fill(null);
	if (typeof lassoData === "object" && lassoedMap) {
		var k = Number(lassoedMap.substr(3));
		ranges[k] = getRangesfromPoints(lassoedMap, lassoData, dict);
	}
	if (app.sPointsParcoords.length == app.m) {
		for (var i=0; i<app.sPointsParcoords.length; i++) {
			var xIDX = "map" + i;
			if (app.sPointsParcoords[i].length == 0) continue;
			//var sPointsParcoords = app.sPointsParcoords[i].map(value => value[0]);
			//console.log(i, xIDX, sPointsParcoords)
			//var w = getRangesfromPoints(xIDX, sPointsParcoords, dict);
			//console.log(i, xIDX, w)
			//ranges[i] = getRangesfromPoints(xIDX, sPointsParcoords, dict);
			ranges[i] = getRangesfromPoints(xIDX, app.sPointsParcoords[i].map(value => value[0]), dict);
		}
	}
	console.log("ranges:", ranges)
	
	// Interval by item
	var colorGradient = app.colorGradient1[1];   // if local
	var colorscales = [[0, colorGradient[0]]];
	var spacing = 1.0 / (colorGradient.length - 1);
	for (var i=1; i<colorGradient.length-1; i++) {
		colorscales.push([colorscales[i-1][0]+spacing, colorGradient[i]]);
	}
	colorscales.push([1, colorGradient[colorGradient.length-1]]);
	console.log("colorscales:", colorscales)
	
	var fixAxes = $('input[type=checkbox][id="parcoords-fixAxes"]').is(":checked");
	//var range = (fixAxes) ? [minValue, maxValue] : null;
	
	var dimensions = [];
	//var n = Math.pow(10, (app.NumOfDecimalPlaces+2));
	//var n = Math.pow(10, 4);
	//console.log(app.NumOfDecimalPlaces, n);
	for (var i=0; i<items.length; i++) {
		var label = layers[i];
		var textLine = splitShortName(label);
		//label = "[Map"+(i+1)+"] "+textLine[0];
		if (app.m > 10) {
			label = "[Map"+(i+1)+"] "+textLine[0];
		}
		dimensions.push(
			{
				//name: "Map"+i,
				range: (fixAxes) ? [minValue, maxValue] : null,
				constraintrange: ranges[i],
				//label: layers[i],
				//label: "[Map"+(i+1)+"] "+layers[i],
				label: label,
				values: array[i],
				//tickformat: ".f",
				tickformat: "."+app.NumOfDecimalPlaces+"f",
			}
		);
	}
	
	//var tickvals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].slice(0, colorGradient.length);
	//var ticktext = tickvals.map(i => " Class "+(i+1));
	var tickvals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].slice(0, intervals.length);
	var ticktext = intervals.map(i => i.toFixed(app.NumOfDecimalPlaces));
	console.log(tickvals, ticktext)
	
	var data = [{
		type: 'parcoords',
		//visible: true,
		//ids: ["Map1", "Map2", "Map3", "Map4", ],
		pad: [80,80,80,80],
		line: {
			showscale: true,
			cmin: 0,
			cmax: nClass-1,
			//color: array[0],
			//colorscale: [[0, '#ffffb2'], [0.1276, '#ffffb2'], [0.9278, '#fed976'], [0.9668, '#feb24c'], [0.976, '#fd8d3c'],[0.9839, '#f03b20'], [0.9914, '#bd0026'], [1, '#bd0026']],
			color: classid,
			colorscale: colorscales,
			//colorscale: [[0, '#0000ff'], [1, '#0000ff']],
			colorbar : {
				thickness: 20,
				tickmode: "array",
				tickvals: tickvals,
				ticktext: ticktext,
			},
		},
		dimensions: dimensions,
	}];
	console.log("data:", data)
	
	var modeBarButtonsToAdd = [{
		name: 'Refresh',
		title: 'Initialize Chart',
		//icon: Plotly.Icons.camera,
		icon:Plotly.Icons.newplotlylogo, 
		click: function (gd) {
			////mouseleaveScatter();
			mouseleaveParallelCoordinates();
			app.sPointsParcoords = [];
			redrawParcoords();
		}
	}];
	
	var layout = {
		margin: {l:100, r:50, b:35, t:75, pad:4},
		yaxis: {
			visible: false,
			//color: "#ff0000",
			showticklabels: false,
			title: {text: "title"},
		},
		showlegend: false,
		hovermode: 'closest',
		//plot_bgcolor: '#E5E5E5',
		paper_bgcolor: '#FAFAFA',
		//paper_bgcolor: '#E5E5E5',
		//paper_bgcolor: '#000000',
	}
	
	//Plotly.plot('chart_ParallelCoordinates', data, layout, {showSendToCloud: true});
	//Plotly.plot(divPCP, data, layout, {showSendToCloud: true});
	Plotly.plot(divPCP, data, layout, {showLink: false, displaylogo: false, modeBarButtonsToAdd: modeBarButtonsToAdd,});
	
	divPCP.on('plotly_restyle', function(eventData) {
		console.log(eventData)
		//console.log("eventData[0]:", eventData[0])
		var constraintranges = divPCP.data[0].dimensions.map(function(d) {
			return d.constraintrange;
		})
		//console.log("constraintranges:", constraintranges)
		mouseleaveParallelCoordinates(this);
		var result = getSelectedPointsfromChart(constraintranges, eventData, geoid, array);
		var sIDX = result[0];
		initializeLassoButtons(sIDX);
		app.sPointsParcoords = result[1];
		console.log($("#"+sIDX+" select[name=ACSdata]").val());
		//$("#PCPchart select[name=ACSdata]").val($("#"+sIDX+" select[name=ACSdata]").val())
		mouseenterParallelCoordinates(this, sIDX);
		//initializeLassoButtons(sIDX);
		// if redraw parallel coordinates chart above, it will call app[mIDX].lasso.disable() automatically without sIDX.
		// this will call mouseenterParallelCoordinates(this, sIDX) with some delay.
		//var i = 0;
		//function repeat_setTimeout() {
		//	setTimeout(function() {
		//		i += 1;
		//		if (i > 10) {
		//			mouseenterParallelCoordinates(this, sIDX);
		//		} else {
		//			repeat_setTimeout();
		//		}
		//	}, 0);
		//}
		//repeat_setTimeout();
	});
	
	function getClassID(val, intervals) {
		if (!$.isNumeric(val) || val == "-9999") {                   // NO DATA
			//return colorGradient[colorGradient.length-1];
			return intervals.length;
		}
		//for (var c=colorGradient.length-2; c>=0; c--) {
		for (var c=intervals.length-1; c>=0; c--) {
			if (val >= intervals[c]) {
				//return colorGradient[c];
				return c;
			}
		}
		//return colorGradient[0];									 // val = 61.81, intervals[0] = 61.81474480151229
		return 0;									 // val = 61.81, intervals[0] = 61.81474480151229
	}
	
	function splitShortName(shortName) {
		var names = [];
		var shorts = (shortName.split(',')).map(str => str.trim());
		for (var i=0; i<shorts.length; i++) {
			if (shorts[i] < 15) {
				names.push(shorts[i]);
				continue;
			}
			words = '';
			var str = shorts[i].split(' ');
			for (var j=0; j<str.length; j++) {
				if (words.length > 9 || (words + str[j]).length > 15) {
					names.push(words.trim());
					words = '';
				}
				words += str[j] + ' ';
			}
			if (words.length > 0) names.push(words.trim());
			
		}
		return names;
	}
}


function getRangesfromPoints(mIDX, geokeys, dict) {
	var k = Number(mIDX.substr(3)) + 1;
	
	// deep copy dict to sDict with filtering mIDX
	var sDict = {};
	for (var key in dict) {
		if (dict.hasOwnProperty(key)) {
			sDict[key] = [dict[key][k], 0];
		}
	}
	
	// set geokeys to sDict
	for (var i=0; i<geokeys.length; i++) {
		if (sDict.hasOwnProperty(geokeys[i])) {
			var values = sDict[geokeys[i]];
			values[1] = 1;
			sDict[geokeys[i]] = values;
		}
	}
	console.log("sDict:", sDict)
	
	// convert sDict to sList
	var cList = [];
	var sList = [];
	for (var key in sDict) {
		if (sDict.hasOwnProperty(key)) {
			var values = sDict[key];
			sList.push([key, values[0], values[1]]);
			if (values[1] == 1) cList.push([key, values[0], values[1]]);
		}
	}
	console.log("cList:", cList)
	
	sList.sort(function(a,b) { return a[1] - b[1]; });
	console.log("sList:", sList)
	
	var ranges = [];
	var fromtoRange = [];
	var previousSelected = 0;
	for (var i=0; i<sList.length; i++) {
		var values = sList[i];
		if (values[2] == 1) {
			if (fromtoRange.length == 0) fromtoRange.push(values[1]);
			else if (fromtoRange.length == 1) fromtoRange.push(values[1]);
			else fromtoRange[1] = values[1];
		} else {
			if (fromtoRange.length == 2) {
				ranges.push(fromtoRange);
				fromtoRange = [];
			} else if (fromtoRange.length == 1) {
				fromtoRange.push(fromtoRange[0]);
				ranges.push(fromtoRange);
				fromtoRange = [];
			}
		}
	}
	if (fromtoRange.length == 2) {
		ranges.push(fromtoRange);
		fromtoRange = [];
	} else if (fromtoRange.length == 1) {
		fromtoRange.push(fromtoRange[0]);
		ranges.push(fromtoRange);
		fromtoRange = [];
	}
	
	//ranges = [];
	//for (var i=0; i<geokeys.length; i++) {
	//	ranges.push([dict[geokeys[i]][k], dict[geokeys[i]][k]]);
	//}
	
	return ranges;
}

function getSelectedPointsfromChart(constraintranges, eventData, geoid, array) {
	var result = array.map(i => []);
	if (Array.isArray(constraintranges)) {
		result = constraintranges.map(i => []);
	} else return [null, result];
	console.log("constraintranges:", constraintranges)
	console.log("eventData[0]:", eventData[0])
	console.log("geoid:", geoid)
	console.log("array:", array)
	var sIDX = null;
	for (var key in eventData[0]) {
		console.log(key)
		if (eventData[0].hasOwnProperty(key)) {
			//var d = "dimensions[31].constraintrange";
			var o = key.match(/[\d+]/);
			if (o && o.index == 11) sIDX = "map" + o[0];
		}
	}
	console.log("sIDX:", sIDX)
	
	var iDict = {};			// key: geoid, value: [value for map1, value for map2, value for map3, ...]
	for (var i=0; i<geoid.length; i++) {
		iDict[geoid[i]] = new Array(app.m).fill(null);
	}
	//console.log("iDict:", iDict)
	
	for (var i=0; i<constraintranges.length; i++) {
		if (!Array.isArray(constraintranges[i])) continue;
		var fromtoRanges = Array.isArray(constraintranges[i][0]) ? constraintranges[i] : [constraintranges[i]];
		for (var j=0; j<array[i].length; j++) {
			for (var k=0; k<fromtoRanges.length; k++) {
				if (fromtoRanges[k][0] <= array[i][j] && array[i][j] <= fromtoRanges[k][1]) {
					//result[i].push([geoid[j], array[i][j]]);
					iDict[geoid[j]][i] = array[i][j];
					break;
				}
			}	
		}
	}
	console.log("iDict:", iDict)
	
	for (var i=0; i<geoid.length; i++) {
		var values = iDict[geoid[i]];
		var selectedCount = 0;
		for (var j=0; j<constraintranges.length; j++) {
			if (!Array.isArray(constraintranges[j])) continue;
			if (values[j] == null) {
				selectedCount = 0;
				break;
			} else selectedCount += 1;
		}
		if (selectedCount > 0) {
			for (var k=0; k<app.m; k++) {
				result[k].push([geoid[i], array[k][i]]);
			}
		}
	}
	console.log("result:", result)
	
	return [sIDX, result];
}

function mouseenterParallelCoordinates(e, sIDX=null) {
	console.log(getNow(), "mouse enter into the chart_ParallelCoordinates  sIDX:", sIDX)
	if (app.sPointsParcoords.length != app.m) {
		//console.log("mouse enter into the chart_ParallelCoordinates but app.m not euqal app.sPointsParcoords.length")
		return;
	}
	setSytleHighlightfromParcoords(app.sPointsParcoords, sIDX);
}

function mouseleaveParallelCoordinates(e) {
	//console.log(getNow(), "mouse leave from the chart_ParallelCoordinates")
	if (app.sPointsParcoords.length != app.m) {
		//console.log("mouse leave from the chart_ParallelCoordinates but app.m not euqal app.sPointsParcoords.length")
		return;
	}
	resetSytlefromParcoords(app.sPointsParcoords);
	//for (var m=0; m<app.sPointsParcoords.length; m++) {
	//	if (app.sPointsParcoords[m].length != 0) {
	//		resetSytle(app.sPointsParcoords(m));
	//	}
	//}
}

// set highlight to style for all maps
function setSytleHighlightfromParcoords(geokeys, sIDX=null, color="#00ffff", weight=3, fillOpacity=0.9) {
	console.log("geokeys:", geokeys)
	console.log("sIDX:", sIDX)
	if (geokeys.length != app.m) return;
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (!app[mapN].geojson) continue;
		//var selectedColor = (mapN != sIDX) ? '#666' : color;
		var selectedColor = (mapN != sIDX) ? color : color;
		for (var j=0; j<geokeys[i].length; j++) {
			var geokey = geokeys[i][j][0];
			var layerN = app[mapN].geojson._layers[app[mapN].layers[geokey]];
			if (!layerN) continue;
			layerN.setStyle({
				color: selectedColor,
				weight: weight,
				fillOpacity: fillOpacity,
				dashArray: '',
			});
		}
	}
}

// reset style for all maps from parallel coordinates plot
function resetSytlefromParcoords(geokeys) {
	if (geokeys.length != app.m) return;
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (!app[mapN].geojson) continue;
		for (var j=0; j<geokeys[i].length; j++) {
			var geokey = geokeys[i][j][0];
			var layerN = app[mapN].geojson._layers[app[mapN].layers[geokey]];
			if (!layerN) continue;
			app[mapN].geojson.resetStyle(layerN);
		}
	}
}

// set highlight to style for all maps from lasso select of maps
function setSytleHighlightfromLassoselect(geokeys, sIDX=null, color="#00ffff", weight=3, fillOpacity=0.9) {
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (!app[mapN].geojson) continue;
		//var selectedColor = (sIDX != null && mapN != sIDX) ? '#666' : color;
		var selectedColor = (sIDX != null && mapN != sIDX) ? color : '#ff00ff';
		for (var j=0; j<geokeys.length; j++) {
			var geokey = geokeys[j];
			var layerN = app[mapN].geojson._layers[app[mapN].layers[geokey]];
			if (!layerN) continue;
			layerN.setStyle({
				color: selectedColor,
				weight: weight,
				fillOpacity: fillOpacity,
				dashArray: '',
			});
		}
	}
}

// reset style for all maps from lasso select of maps
function resetSytlefromLassoselect(geokeys) {
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (!app[mapN].geojson) continue;
		for (var j=0; j<geokeys.length; j++) {
			var geokey = geokeys[j];
			var layerN = app[mapN].geojson._layers[app[mapN].layers[geokey]];
			if (!layerN) continue;
			app[mapN].geojson.resetStyle(layerN);
		}
	}
}


function triggerScatterChart(map0="map0", map1="map1", {lassoData="", eventData=""}={}) {
	initializeLassoButtons(map0);
	if ($('#Scatterchart').length == 0) return;
	
	console.log(getNow(), 'triggerScatterChart started.  ', app.inputType);
	var globalJoin = $('input[type=checkbox][id="globalJoin"]').is(":checked");
	var GorL = null;
	//if (app.inputType == "map2_layer changed") {
	//	console.log(getNow(), 'triggerScatterChart started.  ', app.inputType);
	//	console.log(getNow(), 'triggerScatterChart started.  ', app.inputType);
	//	console.log(getNow(), 'triggerScatterChart started.  ', app.inputType);
	//	console.log(getNow(), 'triggerScatterChart started.  ', app.inputType);
	//	globalJoin = $('input[type=checkbox][id="globalJoin"]').is(":checked");
		console.log("globalJoin:", globalJoin);
		// calculate intervals
		var mIDX = "map2";
		//var drawMode = 2;
		var selectedLayer  = $("#Scatterchart select[name=ACSdata]").val();
	if (selectedLayer != "L000") {
		var classification = $("#global_class select[name=globalClass]").val();
		var nClass = $("#global_count select[name=globalCount]").val();
		
		var item = selectedLayer;
		
		var items = [];
		//var globalJoin = $('input[type=checkbox][id="globalJoin"]').is(":checked");
		//var this_sync = $('input[type=radio][name="'+mIDX+'-radio"]:checked').val();
		//var this_sync = 'auto';
		//for (var i=0; i<app.m; i++) {
		//	var div_id = "map" + i;
		//	var that_sync = $('input[type=radio][name="'+div_id+'-radio"]:checked').val();
		//	if (drawMode != 3) {
		//		if (div_id != mIDX && (this_sync == 'auto' && that_sync == 'manual')) continue;
		//		if (div_id != mIDX && (this_sync == 'manual')) continue;
		//	}
		//	if (drawMode == 3) {
		//		if (app.inputType.indexOf("_syncbtn clicked") < 0)       // ex) "map1_syncbtn clicked"
		//		if (div_id != mIDX && globalJoin == false) continue;
		//	}
		//	var sLayer = $("#"+div_id+" select[name=ACSdata]").val();
		//	items.push(sLayer);
		//}
		items.push(selectedLayer);
		
		app[mIDX].zIntervals = geostats_classification(classification, nClass, CA, items);
		//if (!app[mIDX].zIntervals) {
		//	$("#"+mIDX+"_nPolygon").text("No Data");
		//	clear_map(mIDX);
		//	return;
		//}
		
		app[mIDX].classification = classification;
		app[mIDX].item = item;
		app[mIDX].items = items.toString();
		app[mIDX].mIntervals = geostats_classification(classification, nClass, app.receivedGeoJSON, items);
	} else {
		app[mIDX].zIntervals = null;
		app[mIDX].mIntervals = null;
	}
	paintScatter(map0, map1, {lassoData:lassoData, eventData:eventData, globalJoin:globalJoin});
}

function redrawScatterChart(map0="map0", map1="map1", {lassoData="", eventData=""}={}) {
	initializeLassoButtons(map0);
	console.log(getNow(), 'redrawScatterChart started.  ', app.inputType);
	var globalJoin = null;
	var GorL = null;
	$("#Scatterchart select[name=ACSdata]").val("L000");
	paintScatter(map0, map1, {lassoData:lassoData, eventData:eventData, globalJoin:globalJoin});
}

// check and draw scatter plot
function paintScatter(map0="map0", map1="map1", {lassoData="", eventData="", globalJoin=null}={}) {
//function paintScatter(map0="map0", map1="map1", args) {
	//args = args || {};
	//var lassoData = "";
	//var eventData = "";
	//if (args.hasOwnProperty('lassoData')) lassoData = args('lassoData');
	//if (args.hasOwnProperty('eventData')) eventData = args('eventData');
	
	if ($('#Scatterchart').length == 0) return;
	
	var map2 = "map2";
	console.log("lassoData:", '"'+lassoData+'"', lassoData);
	console.log("eventData:", '"'+eventData+'"', eventData);
	console.log("globalJoin:", globalJoin);
	
	//var zmInterval = globalJoin ? 'mIntervals' : (globalJoin == null ? null : 'zIntervals');
	var zmInterval = globalJoin ? 'zIntervals' : (globalJoin == null ? null : 'zIntervals');		// always zIntervals
	console.log("zmInterval:", zmInterval);
	
	var sameBounds = isTwoBoundsEqual(map0, map1);
	//fadeToWindow("paintScatter")
	Plotly.purge('chart_scatter');
	$("#chart_scatter").html('');
	if (!sameBounds) {
		var html = '';
		html += '<div style="padding:60px 50px; color:blue">';
		html += '<i>';
		html += 'This scatter chart is shown only when all maps have the same extent.<br><br>';
		html += '"Sync", "Join group" and "Grouping All" can be used to make maps have the same extent.';
		html += '</i>';
		html += '</div>';
		$("#chart_scatter").html(html);
		return;
	}
	//$("#chart_scatter").addClass('borderChart');
	var xItem = $("#"+map1+" select[name='ACSdata'] option:selected").val();
	var xText = $("#"+map1+" select[name='ACSdata'] option:selected").text();
	var xGorL = $('input[type=radio][name="'+map1+'-checkbox"]:checked').val();
	var yItem = $("#"+map0+" select[name='ACSdata'] option:selected").val();
	var yText = $("#"+map0+" select[name='ACSdata'] option:selected").text();
	var yGorL = $('input[type=radio][name="'+map0+'-checkbox"]:checked').val();
	var zItem = $("#Scatterchart select[name='ACSdata'] option:selected").val();
	var zText = $("#Scatterchart select[name='ACSdata'] option:selected").text();
	var zGorL = $('input[type=radio][name="Scatterchart-checkbox"]:checked').val();
	//console.log(xItem, xText, xGorL)
	//console.log(yItem, yText, yGorL)
	//console.log(zItem, zText, zGorL)
	var geoid = [];
	var xData = [];
	var yData = [];
	var zData = [];
	var tooltips = [];
	var dict = {};
	var geoJSON = (sameBounds) ? app.selectedGeoJSON : app.receivedGeoJSON;    // always app.selectedGeoJSON ??
	//console.log(geoJSON.features)
	for (var i=0; i<geoJSON.features.length; i++) {
		var row = geoJSON.features[i].properties;
		if (!row.hasOwnProperty(app.geokey)) continue;
		if (!row.hasOwnProperty(xItem) || row[xItem] == -9999 || !row.hasOwnProperty(yItem) || row[yItem] == -9999) continue;
		geoid.push(row[app.geokey])
		var xValue = Number(row[xItem].toFixed(app.NumOfDecimalPlaces));
		var yValue = Number(row[yItem].toFixed(app.NumOfDecimalPlaces));
		var zValue = Number(row[zItem].toFixed(app.NumOfDecimalPlaces));
		xData.push(row[xItem])
		yData.push(row[yItem])
		zData.push(row[zItem])
		tooltips.push(zValue == -9999 ? "x: " + xValue + "<br>" + "y: " + yValue : 
										"x: " + xValue + "<br>" + "y: " + yValue + "<br>" + "Z: " + zValue);
		dict[row[app.geokey]] = [i, xValue, yValue, zValue]
	}
	//console.log("xData:", xData)
	//console.log("yData:", yData)
	//console.log("zData:", zData)
	//console.log("dict:", dict)
	var min_xData = Math.min.apply(Math, xData);
	var max_xData = Math.max.apply(Math, xData);
	var min_yData = Math.min.apply(Math, yData);
	var max_yData = Math.max.apply(Math, yData);
	console.log("min_xData:", min_xData, " max_xData:", max_xData)
	console.log("min_yData:", min_yData, " max_yData:", max_yData)
	
	var markSize = 10;
	if (geoid.length > 100) markSize = 8;
	if (geoid.length > 500) markSize = 6;
	if (geoid.length > 1000) markSize = 3;
	if (geoid.length > 3000) markSize = 1;
	console.log("markSize:", markSize)
	
	mouseleaveScatter();
	app.sPointsScatter = [];
	var selectedpoints = [];
	if (typeof lassoData === "object") {
		for (var i=0; i<lassoData.length; i++) {
			//selectedpoints.push(lassoData[i]);
			if (dict.hasOwnProperty(lassoData[i])) selectedpoints.push(dict[lassoData[i]][0]);
		}
	}
	if (typeof eventData === "object") {
		for (var i=0; i<eventData.points.length; i++) {
			if (eventData.points[i].curveNumber != 0) continue;
			selectedpoints.push(eventData.points[i].pointIndex);
			app.sPointsScatter.push(geoid[eventData.points[i].pointIndex]);
		}
	}
	//console.log('selectedpoints:', selectedpoints);
	//console.log('app.sPointsScatter:', app.sPointsScatter);
	
	var p = numpy.polyfit(numpy.array(xData), numpy.array(yData), 1);
	var a = p[1],  b = p[0];
	var line0 = { 'x': [min_xData, max_xData], 'y': [a + min_xData*b,  a + max_xData*b] };
	
	// recalculation line0 to fit scatter-graph area                                 // y = a * x + b
	var min_point = min_xData;
	var max_point = max_xData;
	var aa = (line0['y'][1] - line0['y'][0]) / (line0['x'][1] - line0['x'][0])
	var bb = line0['y'][0] - aa * line0['x'][0]
	if (line0['y'][0] > max_yData) min_point = (max_yData - bb) / aa;             // x = ( y - b ) / a
	if (line0['y'][0] < min_yData) min_point = (min_yData - bb) / aa;             // x = ( y - b ) / a
	if (line0['y'][1] > max_yData) max_point = (max_yData - bb) / aa;             // x = ( y - b ) / a
	if (line0['y'][1] < min_yData) max_point = (min_yData - bb) / aa;             // x = ( y - b ) / a
	var line0 = { 'x':[min_point, max_point], 'y': [a + min_point*b,  a + max_point*b] };
	
	var colors = '#0066FF';
	//if (zItem != "L000" && zmInterval != null && selectedpoints.length == 0) {
	if (zItem != "L000" && selectedpoints.length == 0) {
		var interval = app[map2][zmInterval];
		//var colorGradient = (zGorL == 'Global') ? app.colorGradient19[0] : app.colorGradient19[1];
		var colorGradient = app.colorGradient19[1];
		//console.log("interval:", interval)
		//console.log("colorGradient:", colorGradient)
		//for (var i=0; i<xData.length; i++) {
		//	colors.push(getColorCode(zData[i], interval, colorGradient));
		//}
		//console.log("colors:", colors)
		colors = zData.map(function(o) { return getColorCode(o, interval, colorGradient) });
		//console.log("colors:", colors)
	}
	
	var data = [
		{
			'x': xData, 
			'y': yData,
			'mode': 'markers',
			hoverinfo: "text",
			//'marker': {'size': 10, 'color': '#0066FF'},
			marker: {
				'size': markSize, 
				'color': colors,
				//'line': {'width': 1},
			},
			selected: { marker: { color: '#FF0066' } },
			//unselected: { marker: { opacity: '#0066FF' } },
			//'name': year.toString(),
			'name': '',
			//'text': geoid,
			'text': tooltips,
		},
		{
			'x': line0['x'], 
			'y': line0['y'],
			'mode': 'lines',
			'line': {'color': '#009999'},
			'name': 'Reg'
		}
	]
	if (selectedpoints.length > 0) data[0]['selectedpoints'] = selectedpoints;
	console.log(data)
	
	//if (typeof eventData === "object" && eventData.points.length > 1) {
	//if (typeof eventData === "object" && selectedpoints.length > 1) {
	if (selectedpoints.length > 1) {
		var xList, yList;
		if (typeof lassoData === "object") {
			xList = selectedpoints.map(function(o) { return xData[o] });
			yList = selectedpoints.map(function(o) { return yData[o] });
		}
		if (typeof eventData === "object") {
			xList = eventData.points.map(function(o) { return xData[o['pointIndex']] });
			yList = eventData.points.map(function(o) { return yData[o['pointIndex']] });
		}
		console.log("xList:", xList)
		console.log("yList:", yList)
		var min_xList = Math.min.apply(Math, xList);
		var max_xList = Math.max.apply(Math, xList);
	
		var p = numpy.polyfit(xList, yList, 1);
		var a = p[1],  b = p[0];
		var line1 = { 'x': [min_xData, max_xData], 'y': [a + min_xData*b,  a + max_xData*b] };
		var line2 = { 'x': [min_xList, max_xList], 'y': [a + min_xList*b,  a + max_xList*b] };
	
		// recalculation line1 to fit scatter-graph area                                 // y = a * x + b
		var min_point = min_xData;
		var max_point = max_xData;
		var aa = (line1['y'][1] - line1['y'][0]) / (line1['x'][1] - line1['x'][0])
		var bb = line1['y'][0] - aa * line1['x'][0]
		if (line1['y'][0] > max_yData) min_point = (max_yData - bb) / aa;             // x = ( y - b ) / a
		if (line1['y'][0] < min_yData) min_point = (min_yData - bb) / aa;             // x = ( y - b ) / a
		if (line1['y'][1] > max_yData) max_point = (max_yData - bb) / aa;             // x = ( y - b ) / a
		if (line1['y'][1] < min_yData) max_point = (min_yData - bb) / aa;             // x = ( y - b ) / a
		var line1 = { 'x':[min_point, max_point], 'y': [a + min_point*b,  a + max_point*b] };
	
		data.push(
			{
				'x': line1['x'], 
				'y': line1['y'],
				'mode': 'lines', 
				//'line': {'color': '#FF6600'},
				'line': {'color': '#FF0000'}, //0000FF
				'name': 'Reg'}
		)
		//data.push(
		//	{
		//		'x': line2['x'], 
		//        'y': line2['y'],
		//        'mode': 'lines', 
		//        'line': {'color': '#FF0000'},
		//        'name': 'Reg'}
		//)
	}
	//console.log(data);
	
	//var modeBarButtons = [[ "resetViews", "zoom2d", "pan2d" ]];
	var modeBarButtonsToAdd = [{
		name: 'Refresh',
		title: 'Initialize Chart',
		//icon: Plotly.Icons.camera,
		icon:Plotly.Icons.newplotlylogo, 
		click: function (gd) {
			mouseleaveScatter();
			redrawScatterChart(map0, map1, {});
		}
	}];
	
	var title_msg = '';
	if (app[map2].item && $("#Scatterchart select[name=ACSdata]").val() == "L000") {
		title_msg = {text: '<br><br><i>Mouse right-click to go back to the previous state.</i>', font: {size:13, color: "#0000ff"}};
	}
	var layout = {
		//autosize: false,
		//width: 500,
		//height: 500,
		//margin: {l:25, r:25, b:25, t:25, pad:4},
		margin: {l:35, r:35, b:35, t:35, pad:4},
        //'xaxis': {'title': xText.substr(5)},
		//'yaxis': {'title': yText.substr(5)},
		xaxis: {autorange: true, showgrid: true, zeroline: false, showline: true, showticklabels: false, 'title': xText},
        yaxis: {autorange: true, showgrid: true, zeroline: false, showline: true, showticklabels: false, 'title': yText},
        showlegend: false,
        //'title': {text: 'Scatter Plot for   ' + 'Y: Map1   X: Map2', font: {size:14}},
		//title: (sameBounds) ? '' : '<br>Map1, 2 are not same bounds.',
		title: title_msg,
		dragmode: 'lasso',
		hovermode: 'closest',
		paper_bgcolor: '#FAFAFA',
		plot_bgcolor: '#FAFAFA',
		
    }
	
	Plotly.plot("chart_scatter", data, layout, {showLink: false, displaylogo: false, modeBarButtonsToAdd: modeBarButtonsToAdd,});
	//Plotly.plot("chart_scatter", data, layout, {showLink: false, displaylogo: false, modeBarButtons: modeBarButtons,});
	
	var scatterDiv = document.getElementById('chart_scatter');
	scatterDiv.on('plotly_selected', function(eventData) {
		//console.log("plotly_selected:", eventData);
		if (typeof eventData !== "object" || !("points" in eventData) || eventData.points.length == 0) return;
		console.log("plotly_selected:", eventData.points);
		redrawScatterChart(map0, map1, {eventData:eventData});
	});
	scatterDiv.on('plotly_click', function(eventData) {
		//console.log("plotly_click:", eventData);
		if (typeof eventData !== "object" || !("points" in eventData) || eventData.points.length == 0) return;
		console.log("plotly_click:", eventData.points);
		redrawScatterChart(map0, map1, {eventData:eventData});
	});
	
	function getColorCode(val, intervals, colorGradient) {
		if (!$.isNumeric(val) || val == "-9999") {                   // NO DATA
			return colorGradient[colorGradient.length-1];
		}
		for (var c=colorGradient.length-2; c>=0; c--) {
			if (val >= intervals[c]) {
				return colorGradient[c];
			}
		}
		return colorGradient[0];									 // val = 61.81, intervals[0] = 61.81474480151229
	}
}


function oncontextScatter(e) {
	console.log(this)
	console.log(e)
	e.preventDefault();
	console.log("right click on the chart_scatter", app.map2.item)
	//setSytleHighlightfromScatter(app.sPointsScatter);
}

function mouseenterScatter(e) {
	//console.log("mouse enter into the chart_scatter")
	setSytleHighlightfromScatter(app.sPointsScatter);
}

function mouseleaveScatter(e) {
	//console.log("mouse leave from the chart_scatter")
	resetSytlefromScatter(app.sPointsScatter);
}


// set highlight to style for all maps
function setSytleHighlightfromScatter(geokeys, sIDX=null, color="#00ffff", weight=3, fillOpacity=0.9) {
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (!app[mapN].geojson) continue;
		var selectedColor = (sIDX != null && mapN != sIDX) ? '#666' : color;
		for (var j=0; j<geokeys.length; j++) {
			var geokey = geokeys[j];
			var layerN = app[mapN].geojson._layers[app[mapN].layers[geokey]];
			if (!layerN) continue;
			layerN.setStyle({
				color: selectedColor,
				weight: weight,
				fillOpacity: fillOpacity,
				dashArray: '',
			});
		}
	}
}

// reset style for all maps
function resetSytlefromScatter(geokeys) {
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		if (!app[mapN].geojson) continue;
		for (var j=0; j<geokeys.length; j++) {
			var geokey = geokeys[j];
			var layerN = app[mapN].geojson._layers[app[mapN].layers[geokey]];
			if (!layerN) continue;
			app[mapN].geojson.resetStyle(layerN);
		}
	}
}


// check and draw correlogram
function triggerCorrelogram() {
	//if ($("#correlogram").length == 0) return;
	if (!app.Correlogram) return;
	var sameBounds = isAllBoundsEqual();
	console.log("sameBounds:", sameBounds)
	if (!sameBounds) return;
	fadeToWindow("correlogram")
	$("#correlogram").html("");
	
	var globalJoin = $('input[type=checkbox][id="globalJoin"]').is(":checked");
	console.log("globalJoin:", globalJoin)
	
	var showedLayers = [];
	var GorLs = [];
	for (var i=0; i<app.m; i++) {
		var mapN = "map" + i;
		var label = $("#"+mapN+" select[name='ACSdata'] option:selected").val();
		var text = $("#"+mapN+" select[name='ACSdata'] option:selected").text();
		var GorL = $('input[type=radio][name="'+mapN+'-checkbox"]:checked').val();
		//console.log(label, text)
		showedLayers.push(label);
		GorLs.push(GorL);
	}
	console.log("showedLayers:", showedLayers)
	console.log("GorLs:", GorLs)
	
	var data = [];
	var geoJSON = (sameBounds) ? app.selectedGeoJSON : app.receivedGeoJSON;    // always app.selectedGeoJSON ??
	console.log(geoJSON.features)
	for (var i=0; i<geoJSON.features.length; i++) {
		row = geoJSON.features[i].properties;
		//console.log(i, row)
		aDictionary = {};
		if (!row.hasOwnProperty(app.geokey)) continue;
		aDictionary[app.geokey] = row[app.geokey];
		var nCols = 0;
		for (var j=0; j<showedLayers.length; j++) {
			var key = showedLayers[j];
			if (!row.hasOwnProperty(key)) continue;
			if (row[key] == -9999) console.log(row[app.geokey], key, row[key]);
			else {
				nCols += 1;
				aDictionary[key] = Number(row[key].toFixed(2));
			}
		}
		if (nCols >= 1) data.push(aDictionary)
	}
	//console.log("data:", data)
	
	//fadeToWindow("correlogram")
	//drawCorrelogram("correlogram", data, showedLayers, 'Global');
	drawCorrelogram("correlogram", data, showedLayers, globalJoin, GorLs);
	fadeOutWindow("correlogram");
}

// https://www.d3-graph-gallery.com/graph/correlogram_histo.html
//function drawCorrelogram(svgid, data, allVar, GorL, sizeSquare) {
function drawCorrelogram(svgid, data, allVar, globalJoin, GorLs, sizeSquare) {
	
	var zmInterval = (globalJoin) ? 'mIntervals' : 'zIntervals';
	
	var numVar = allVar.length;

	// Set default square size of this correlogram by pre ES2015 style
	if (typeof sizeSquare !== 'undefined') {} else {
		//var sizeSquareTable = {	1: '600px', 2: '700px', 3: '800px', 4: '900px', 5: '1000px', 
		//						6: '1050px', 7: '1050px', 8: '1225px', 9: '1400px', 10: '1575px', 
		//						11: '1750px', 12: '1925px', 13: '2100px', 14: '2275px', 15: '2450px'};
		var sizeSquareTable = {	1: '600px', 2: '700px', 3: '800px', 4: '900px', 5: '1100px', 
								6: '1100px', 7: '1225px', 8: '1400px', 9: '1575px', 10: '1750px', 
								11: '1925px', 12: '2100px', 13: '2275px', 14: '2450px', 15: '2625px'};
		sizeSquare = 1000;
		if (sizeSquareTable.hasOwnProperty(numVar)) sizeSquare = sizeSquareTable[numVar].replace('px', '');
	}
	
	var circleSize = 4;
	if (numVar > 2) circleSize = 3;
	if (numVar > 4) circleSize = 2;
	if (numVar > 6) circleSize = 1;
	//if (numVar > 8) circleSize = 0.5;
	
	var fontSize = '16'+'px';
	if (numVar >= 2) fontSize = '13'+'px';
	if (numVar >= 3) fontSize = '10'+'px';
	//if (numVar >= 5) fontSize = '10'+'px';
	//if (numVar > 8) fontSize = '8'+'px';
	
	var fontSizePCC = '16'+'px';
	if (numVar > 4) fontSizePCC = '14'+'px';
	if (numVar > 6) fontSizePCC = '12'+'px';
	//if (numVar > 8) fontSizePCC = '8'+'px';

	// Dimension of the whole chart. Only one size since it has to be square
	var marginWhole = {top: 20, right: 20, bottom: 20, left: 20},
		sizeWhole = sizeSquare - marginWhole.left - marginWhole.right
		
	// Create the svg area
	var svg = d3.select("#"+svgid)
		.append("svg")
			.attr("width", sizeWhole  + marginWhole.left + marginWhole.right)
			.attr("height", sizeWhole  + marginWhole.top + marginWhole.bottom)
		.append("g")
			.attr("transform", "translate(" + marginWhole.left + "," + marginWhole.top + ")");
	
	//d3.csv("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/iris.csv", function(data) {
	//d3.csv("GEO_VARIABLES_LA_12variables_2000.csv", function(data) {
	
	// What are the numeric variables in this dataset? How many do I have
	//var allVar = ["Sepal_Length", "Sepal_Width", "Petal_Length", "Petal_Width"]
	// -9999 Must be Removed
	
	// Now I can compute the size of a single chart
	var mar = 30
	var size = sizeWhole / numVar
	
	
	// ----------------- //
	// Scales
	// ----------------- //
	
	// Create a scale: gives the position of each pair each variable
	var position = d3.scalePoint()
		.domain(allVar)
		.range([0, sizeWhole-size])
	
	// Color scale: give me a specie name, I return a color
	//var color = d3.scaleOrdinal()
	//	.domain(["0", "1", "2", "3","4", "5", "6", "7", "8"])
	//	.range(app.colorGradient)
	
	
	// ------------------------------- //
	// Add charts
	// ------------------------------- //
	for (var i=0; i<allVar.length; i++) {
		for (var j=0; j<allVar.length; j++) {
			
			// Get current variable name
			var var1 = allVar[i]
			var var2 = allVar[j]
			
			// If var1 == var2 i'm on the diagonal, I skip that
			if (var1 === var2) { continue; }
			
			var width = size-2*mar;
			var height = size-2*mar;
			
			// Add X Scale of each graph
			var xextent = d3.extent(data, function(d) { return +d[var1] })
			//var xextent = d3.extent(dataDic[var1])
			//console.log(xextent)
			var x = d3.scaleLinear()
				.domain(xextent).nice()
				.range([ 0, size-2*mar ]);
			
			// Add Y Scale of each graph
			var yextent = d3.extent(data, function(d) { return +d[var2] })
			//var yextent = d3.extent(dataDic[var2])
			//console.log(yextent)
			var y = d3.scaleLinear()
				.domain(yextent).nice()
				.range([ size-2*mar, 0 ]);
			
			// Add a 'g' at the right position
			var tmp = svg
				.append('g')
				.attr("transform", "translate(" + (position(var1)+mar) + "," + (position(var2)+mar) + ")");
			//console.log(position(var1)+mar, position(var2)+mar)
			
			// Add X and Y axis in tmp
			tmp.append("g")
				.attr("transform", "translate(" + 0 + "," + (size-mar*2) + ")")
				.call(d3.axisBottom(x).ticks(3).tickFormat(d3.format(".0s")))
				
				.selectAll("text")												
				    //.style("text-anchor", "middle")
					.attr("font-size", "8px");				
				
			tmp.append("g")
				.attr("class", "axis")
				.call(d3.axisLeft(y).ticks(3).tickFormat(d3.format(".0s")))
				
				//.attr("width", "10")
				.selectAll("text")												
				    .style("text-anchor", "end")
					.attr("font-size", "8px")
					//.attr("transform", "translate("+margin.left+","+margin.top+")");
					.attr("transform", "rotate(45)");
			
			// Reformat the data: d3.hexbin() needs a specific format
			var inputForHexbinFun = []
			data.forEach(function(d) {
				//inputForHexbinFun.push( [x(d.x), y(d.y)] )  // Note that we had the transform value of X and Y !
				inputForHexbinFun.push( [x(+d[var1]), y(+d[var2])] )
			})
			//console.log(inputForHexbinFun)
			
			// Prepare a color palette
			var color = d3.scaleLinear()
				//.domain([0, 10]) // Number of points in the bin?
				.domain([0, 3]) // Number of points in the bin?
				//.range(["transparent",  "#69b3a2"])
				.range(["transparent",  "#0040ff"])
			
			// Compute the hexbin data
			var hexbin = d3.hexbin()
				.radius(2) // size of the bin in px
				//.radius(6) // size of the bin in px
				.extent([ [0, 0], [width, height] ])
			//console.log("hexbin:", hexbin)
				
			// Plot the hexbins
			tmp.append("clipPath")
				.attr("id", "clip")
				.append("rect")
				.attr("width", width)
				.attr("height", height)
			
			tmp.append("g")
				.attr("clip-path", "url(#clip)")
				.selectAll("path")
				.data( hexbin(inputForHexbinFun) )
				.enter().append("path")
					.attr("d", hexbin.hexagon())
					.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
					.attr("fill", function(d) { return color(d.length); })
					.attr("stroke", "black")
					//.attr("stroke-width", "0.1")
					.attr("stroke-width", "0.0")
			
/*			
			// Add circle
			tmp
				.selectAll("myCircles")
				.data(data)
				.enter()
				.append("circle")
					.attr("cx", function(d) { return x(+d[var1]); })
					.attr("cy", function(d) { return y(+d[var2]); })
					.attr("r", circleSize)
					.attr("fill", function(d){
						//if (d.geoid != "06037920329") return "#FFB3B3";
						//var val = (i < j) ? +d[var1] : +d[var2];
						var val = (i < j) ? +d[var2] : +d[var2];
						//var interval = (i < j) ? app['map'+i][zmInterval] : app['map'+j][zmInterval];
						var interval = (i < j) ? app['map'+j][zmInterval] : app['map'+j][zmInterval];
						return getColorCode(val, interval); 
					})
*/			
			var xlabel = (var1.substr(0,4) in app.labdic) ? app.labdic[var1.substr(0,4)].shortName : var1;
			var ylabel = (var2.substr(0,4) in app.labdic) ? app.labdic[var2.substr(0,4)].shortName : var2;

			if (numVar < 6){			
				tmp.append('text')
					.attr("x", size*1/3)
					.attr("y", size-mar+5)
					.text(xlabel.substring(0, 41))
					.attr("font-size", fontSize)
					.attr("text-anchor", "middle")
				tmp.append('text')			
					.attr("transform", "rotate(-90)")
	
					.attr("x", 0-size*1/3)
					.attr("y", 0-mar+5)
					.text(ylabel.substring(0, 41))
					.attr("font-size", fontSize)
					.attr("text-anchor", "middle")
			}else{
				tmp.append('text')
					.attr("x", size*1/3)
					.attr("y", size-mar+5)
					.text(xlabel.substring(0, 34))
					.attr("font-size", fontSize)
					.attr("text-anchor", "middle")
				tmp.append('text')			
					.attr("transform", "rotate(-90)")
	
					.attr("x", 0-size*1/3)
					.attr("y", 0-mar+5)
					.text(ylabel.substring(0, 34))
					.attr("font-size", fontSize)
					.attr("text-anchor", "middle")			
			}
			
			// Pearson correlation coefficient
			//var inputForPearsonCorrelation = [data.map(row => row[var1]), data.map(row => row[var2])];
			//var pcc = pearsonCorrelation(inputForPearsonCorrelation, 0, 1).toFixed(2);
			//console.log(var1, var2, pcc)
			
			var list1 = [];
			var list2 = [];
			var rCount = 0;
			for (var m=0; m<data.length; m++) {
				//if ( app.geokey
				var row = data[m];
				if (row.hasOwnProperty(var1) && row.hasOwnProperty(var2)) {
					list1.push(row[var1]);
					list2.push(row[var2]);
				} else {
					if (row.hasOwnProperty(var1) || row.hasOwnProperty(var2)) {
						rCount += 1;
						//console.log("Rejected in correlation coefficient  " +
						//			"var1:" + var1 + "  var2:" + var2, [row[var1], row[var2]]);
					}
				}
			}
			if (rCount != 0)
			console.log("Rejected count in correlation coefficient  " + "var1: " + var1 + "  var2: " + var2 + "  =>  ", rCount);
			var pcc = corr(list1, list2).toFixed(2);
			
			tmp.append('text')
				.attr("x", size*1/2)
				.attr("y", size*1/5)
				.text(function (d) { 
					return pcc;
				})
				//.attr("fill", "#ff4000")
				//.attr("font-family", "Georgia")
				.attr("font-weight", "bold")
				.attr("font-size", fontSizePCC)
				.attr("text-anchor", "middle")
		}
	}
	
	
	// ------------------------------- //
	// Add histograms = diagonal
	// ------------------------------- //
	for (var i=0; i<allVar.length; i++) {
		for (var j=0; j<allVar.length; j++) {
			
			// variable names
			var var1 = allVar[i]
			var var2 = allVar[j]
			
			// If var1 == var2 i'm on the diagonal, otherwisee I skip
			if (i != j) { continue; }
			
			var width = size-2*mar;
			var height = size-2*mar;
			
			// create X Scale
			xextent = d3.extent(data, function(d) { return +d[var1] })
			var x = d3.scaleLinear()
				.domain(xextent).nice()
				//.domain([0, 1000])
				.range([ 0, size-2*mar ]);
			
			// Compute kernel density estimation //100 300,000
			var kde = kernelDensityEstimator(kernelEpanechnikov(xextent[1]*0.07), x.ticks(40))
			var density = kde( data.map(function(d){ return +d[var1]; }) )
			//console.log(density)
			
			// Add a 'g' at the right position
			var tmp = svg
				.append('g')
				.attr("transform", "translate(" + (position(var1)+mar) + "," + (position(var2)+mar) + ")");
			
			// set the parameters for the histogram
			var histogram = d3.histogram()
				//.frequency(false)
				.value(function(d) { return +d[var1]; })			 // I need to give the vector of value
				.domain(x.domain())									 // then the domain of the graphic
				.thresholds(x.ticks(15));							 // then the numbers of bins
			
			// And apply this function to data to get the bins
			var bins = histogram(data);
			
			// Y axis: scale and draw:
			var y = d3.scaleLinear()
				.range([ size-2*mar, 0 ])
				.domain([0, d3.max(bins, function(d) { return d.length; })]);   // d3.hist has to be called before the Y axis obviously
			
			var yd = d3.scaleLinear()
				.range([ size-2*mar, 0 ])
				.domain([d3.min(density.map(row => row[1])), d3.max(density.map(row => row[1]))])
			
			// Add X and Y axis in tmp
			tmp.append("g")
				.attr("transform", "translate(" + 0 + "," + (size-mar*2) + ")")
				.call(d3.axisBottom(x).ticks(3).tickFormat(d3.format(".0s")))
				.selectAll("text")												
					.attr("font-size", "8px");	
					
			tmp.append("g")
				.call(d3.axisLeft(y).ticks(3).tickFormat(d3.format(".0s")))
				.selectAll("text")												
				    .style("text-anchor", "end")
					.attr("font-size", "8px")
					.attr("transform", "rotate(45)");
			
			// append the bar rectangles to the svg element
			tmp.append('g')
				.selectAll("rect")
				.data(bins)
				.enter()
				.append("rect")
					.attr("x", 1)
					//.attr("x", d => x(d.x0) + 1)
					//.attr("y", d => y(d.length / data.length))
					.attr("transform", function(d) { return "translate(" + x(d.x0) + "," + y(d.length) + ")"; })
					.attr("width", function(d) { return x(d.x1) - x(d.x0)  ; })
					.attr("height", function(d) { return (size-2*mar) - y(d.length); })
					.style("fill", "#b8b8b8")
					.attr("stroke", "white")

			// Plot the area
			tmp.append("path")
				.attr("class", "mypath")
				.datum(density)
				//.attr("fill", "#69b3a2")
				.attr("fill", "none")
				.attr("opacity", ".8")
				.attr("stroke", "#ff0000")
				.attr("stroke-width", 1.5)
				.attr("stroke-linejoin", "round")
				.attr("d",  d3.line()
					.curve(d3.curveBasis)
						.x(function(d) { return x(d[0]); })
						.y(function(d) { return yd(d[1]); })
				);
/*			
			tmp.append('text')
				.attr("x", size*1/3)
				.attr("y", size*1/3)
				//.attr("y", size-mar+5)
				.text(function (d) { 
					return (var1.substr(0,4) in codesbyIndex) ? codesbyIndex[var1.substr(0,4)].shortName : var1; 
				})
				.attr("font-weight", "bold")
				.attr("font-size", fontSize)
				.attr("text-anchor", "middle")
*/		
				
			//var textList = (var1.substr(0,4) in codesbyIndex) ? codesbyIndex[var1.substr(0,4)].shortName : var1;
			var textList = (var1.substr(0,4) in app.labdic) ? app.labdic[var1.substr(0,4)].shortName : var1;
			var textLine = splitShortName(textList);
			//const lineHeight = 1.2;
			const textHeight = Number(fontSizePCC.replace('px', '')) + 2;
			
			for (var t=0; t<textLine.length; t++) {
				tmp.append('text')
					.attr("x", size*1/3)
					.attr("y", size*1/6+textHeight*t)
					.text(textLine[t])
					.attr("font-weight", "bold")
					.attr("font-size", fontSizePCC)
					.attr("text-anchor", "middle")
			}		
		}
	}
	
	
	function getColorCode(val, intervals) {
		//var intervals = (GorL == "Global") ? mIntervals : zIntervals;
		//var m = zm;
		//if (interval == 'm') {intervals = mIntervals; m = 0;}
		//if (interval == 'z') {intervals = zIntervals; m = 1;}
		if (!$.isNumeric(val) || val == "-9999") {                   // NO DATA
			//if (app.colorGradient1[m].indexOf("#252525") == -1) return "#5E5E5E";
			//else return "#FFB3B3";
			//console.log(val)
			//return (app.colorGradient.length-1).toString();
			return "#5E5E5E";
		}
		//for (var c=app.colorGradient1[m].length-1; c>=0; c--) {
		for (var c=app.colorGradient.length-2; c>=0; c--) {
			if (val >= intervals[c]) {
				//return app.colorGradient1[m][c];
				//return c.toString();
				//console.log(val, c, app.colorGradient[c])
				return app.colorGradient[c];
			}
		}
	}
	
	function splitShortName(shortName) {
		var names = [];
		var shorts = (shortName.split(',')).map(str => str.trim());
		for (var i=0; i<shorts.length; i++) {
			if (shorts[i] < 15) {
				names.push(shorts[i]);
				continue;
			}
			words = '';
			var str = shorts[i].split(' ');
			for (var j=0; j<str.length; j++) {
				if (words.length > 9 || (words + str[j]).length > 15) {
					names.push(words.trim());
					words = '';
				}
				words += str[j] + ' ';
			}
			if (words.length > 0) names.push(words.trim());
			
		}
		return names;
	}
	
	// Function to compute density
	function kernelDensityEstimator(kernel, X) {
		return function(sample) {
			return X.map(function(x) {
				return [x, d3.mean(sample, function(v) { return kernel(x - v); })];
			});
		};
	}
	
	function kernelEpanechnikov(bandwith) {
		return function(v) {
			return Math.abs(v /= bandwith) <= 1 ? 0.75 * (1 - v * v) / bandwith : 0;
		};
	}
	
	/**
	* calculates pearson correlation
	* @param {number[]} d1
	* @param {number[]} d2
	*/
	function corr(d1, d2) {
		let { min, pow, sqrt } = Math
		let add = (a, b) => a + b
		let n = min(d1.length, d2.length)
		if (n === 0) {
			return 0
		}
		//[d1, d2] = [d1.slice(0, n), d2.slice(0, n)]
		let [sum1, sum2] = [d1, d2].map(l => l.reduce(add))
		let [pow1, pow2] = [d1, d2].map(l => l.reduce((a, b) => a + pow(b, 2), 0))
		let mulSum = d1.map((n, i) => n * d2[i]).reduce(add)
		let dense = sqrt((pow1 - pow(sum1, 2) / n) * (pow2 - pow(sum2, 2) / n))
		if (dense === 0) {
			return 0
		}
		return (mulSum - (sum1 * sum2 / n)) / dense
	}
}


function isPolygonInMapBounds(feature, baseLines, west, south, east, north) {

	// false, if the bounds of Polygon are completely out of Rectangle
	var geoBounds = d3.geoBounds(feature);
	if (geoBounds[0][0] > east  ||
		geoBounds[1][0] < west  ||
		geoBounds[0][1] > north ||
		geoBounds[1][1] < south) return false;
	
	// 1st: check the first point of Polygon against the Rectangle
	var coordinates = [];
	if (feature.geometry.type == 'Polygon') {
		coordinates.push(feature.geometry.coordinates[0][0]);
	}		
	if (feature.geometry.type == 'MultiPolygon') {
		for (var i=0; i<feature.geometry.coordinates.length; i++) {
			coordinates.push(feature.geometry.coordinates[i][0][0]);
		}
	}
	for (var i=0; i<coordinates.length; i++) {
		var point = coordinates[i];
		if (west  <= point[0] && point[0] <= east &&
			south <= point[1] && point[1] <= north) return true;
	}
	
	// 2nd: check the bottom left corner point in Rectangle against the Polygon          
	if (d3.geoContains(feature, [west, south])) return true;
	
	// 3rd: check the lines of Rectangle against the Polygon          
	var drawLines = lineify(feature);
	var crossPoints = [];
	for (var i=0; i<drawLines.geometries.length; i++) {
		for (var j=0; j<baseLines.geometries.length; j++) {
			var crossTest = lineStringsIntersect(drawLines.geometries[i], baseLines.geometries[j]);
			if (crossTest) {
				for (var k=0; k<crossTest.length; k++) {
					crossPoints.push(crossTest[k]);
				}
			}
		}
	}
	if (crossPoints.length != 0) return true;
	
	return false;
}


////////////////////////////////////////////////////////////////////////////////////////////
//intersection and geometry conversion functions form nathansnider's public fiddles       //
////////////////////////////////////////////////////////////////////////////////////////////

// corrected intersection code from https://github.com/maxogden/geojson-js-utils
// (using projected coordinates, because straight lat/lons will produce incorrect results)
// originally adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js
function lineStringsIntersect(l1, l2) {
    var intersects = [];
    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {
        for (var j = 0; j <= l2.coordinates.length - 2; ++j) {
            var a1Latlon = L.latLng(l1.coordinates[i][1], l1.coordinates[i][0]),
                a2Latlon = L.latLng(l1.coordinates[i + 1][1], l1.coordinates[i + 1][0]),
                b1Latlon = L.latLng(l2.coordinates[j][1], l2.coordinates[j][0]),
                b2Latlon = L.latLng(l2.coordinates[j + 1][1], l2.coordinates[j + 1][0]),
                a1 = L.Projection.SphericalMercator.project(a1Latlon),
                a2 = L.Projection.SphericalMercator.project(a2Latlon),
                b1 = L.Projection.SphericalMercator.project(b1Latlon),
                b2 = L.Projection.SphericalMercator.project(b2Latlon),
                ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
                ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
                u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
            if (u_b != 0) {
                var ua = ua_t / u_b,
                    ub = ub_t / u_b;
                if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
                    var pt_x = a1.x + ua * (a2.x - a1.x),
                        pt_y = a1.y + ua * (a2.y - a1.y),
                        pt_xy = {
                            "x": pt_x,
                                "y": pt_y
                        },
                        pt_latlon = L.Projection.SphericalMercator.unproject(pt_xy);
                    intersects.push({
                        'type': 'Point',
                            'coordinates': [pt_latlon.lng, pt_latlon.lat]
                    });
                }
            }
        }
    }
    if (intersects.length == 0) intersects = false;
    return intersects;
}

//takes GeoJSON as input, creates a GeoJSON GeometryCollection of linestrings as output
// from https://gis.stackexchange.com/questions/170919/how-to-tell-if-a-geojson-path-intersects-with-another-feature-in-leaflet
function lineify(inputGeom) {
    var outputLines = {
        "type": "GeometryCollection",
            "geometries": []
    }
    switch (inputGeom.type) {
        case "GeometryCollection":
            //for (var i in inputGeom.geometries) {
			for (var i=0; i<inputGeom.geometries.length; i++) {
                var geomLines = lineify(inputGeom.geometries[i]);
                if (geomLines) {
					for (var j=0; j<geomLines.geometries.length; j++) {
                        outputLines.geometries.push(geomLines.geometries[j]);
                    }
                } else {
                    outputLines = false;
                }
            }
            break;
        case "Feature":
            var geomLines = lineify(inputGeom.geometry);
            if (geomLines) {
				for (var j=0; j<geomLines.geometries.length; j++) {
                    outputLines.geometries.push(geomLines.geometries[j]);
                }
            } else {
                outputLines = false;
            }
            break;
        case "FeatureCollection":
			for (var i=0; i<inputGeom.features.length; i++) {
                var geomLines = lineify(inputGeom.features[i].geometry);
                if (geomLines) {
                    //for (var j in geomLines.geometries) {
					for (var j=0; j<geomLines.geometries.length; j++) {
                        outputLines.geometries.push(geomLines.geometries[j]);
                    }
                } else {
                    outputLines = false;
                }
            }
            break;
        case "LineString":
            outputLines.geometries.push(inputGeom);
            break;
        case "MultiLineString":
        case "Polygon":
            for (var i=0; i<inputGeom.coordinates.length; i++) {
                outputLines.geometries.push({
                    "type": "LineString",
                        "coordinates": inputGeom.coordinates[i]
                });
            }
            break;
        case "MultiPolygon":
			for (var i=0; i<inputGeom.coordinates.length; i++) {
				for (var j=0; j<inputGeom.coordinates[i].length; j++) {
                    outputLines.geometries.push({
                        "type": "LineString",
                            "coordinates": inputGeom.coordinates[i][j]
                    });
                }
            }
            break;
        default:
            outputLines = false;
    }
    return outputLines;
}

	</script>

</body>
</html>
